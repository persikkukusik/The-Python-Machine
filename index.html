<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SnakeScratch ‚Äî Visual Python</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Space+Mono:wght@400;700&family=Rubik:wght@400;500;700;900&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0d0f1a;
    --surface: #13152a;
    --surface2: #1a1d35;
    --surface3: #21254a;
    --border: #2a2f5a;
    --accent: #7c5cfc;
    --accent2: #00e5ff;
    --accent3: #ff6b6b;
    --accent4: #ffd166;
    --accent5: #06d6a0;
    --text: #e8eaff;
    --text-dim: #6b7099;
    --text-muted: #3a3f6e;

    --cat-control: #7c5cfc;
    --cat-data: #00b4d8;
    --cat-math: #06d6a0;
    --cat-logic: #ff6b6b;
    --cat-function: #ffd166;
    --cat-io: #ff9f1c;
    --cat-list: #c77dff;
    --cat-string: #43aa8b;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Rubik', sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* ---- HEADER ---- */
  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 0 20px;
    height: 52px;
    display: flex;
    align-items: center;
    gap: 16px;
    flex-shrink: 0;
    z-index: 100;
  }

  .logo {
    font-family: 'Space Mono', monospace;
    font-weight: 700;
    font-size: 18px;
    color: var(--accent);
    letter-spacing: -1px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .logo-snake { font-size: 22px; }

  .header-btns {
    display: flex;
    gap: 8px;
    margin-left: auto;
    align-items: center;
  }

  .btn {
    padding: 7px 16px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-family: 'Rubik', sans-serif;
    font-weight: 600;
    font-size: 13px;
    transition: all 0.15s;
  }
  .btn-primary {
    background: var(--accent);
    color: white;
  }
  .btn-primary:hover { background: #9070ff; transform: translateY(-1px); }
  .btn-secondary {
    background: var(--surface3);
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover { background: var(--surface2); }
  .btn-danger {
    background: transparent;
    color: var(--accent3);
    border: 1px solid var(--accent3);
  }
  .btn-danger:hover { background: rgba(255,107,107,0.1); }

  .project-name {
    background: transparent;
    border: 1px solid transparent;
    color: var(--text);
    font-family: 'Rubik', sans-serif;
    font-size: 14px;
    padding: 4px 8px;
    border-radius: 6px;
    outline: none;
    transition: border-color 0.15s;
  }
  .project-name:focus { border-color: var(--accent); background: var(--surface2); }

  /* ---- MAIN LAYOUT ---- */
  .app {
    display: grid;
    grid-template-columns: 220px 1fr 340px;
    height: calc(100vh - 52px);
    overflow: hidden;
  }

  /* ---- SIDEBAR / BLOCK PALETTE ---- */
  .sidebar {
    background: var(--surface);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .sidebar-tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .sidebar-tab {
    flex: 1;
    padding: 10px;
    text-align: center;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.15s;
    border-bottom: 2px solid transparent;
    letter-spacing: 0.5px;
    text-transform: uppercase;
  }
  .sidebar-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
  .sidebar-tab:hover:not(.active) { color: var(--text); }

  .block-categories { overflow-y: auto; flex: 1; padding: 8px; }
  .block-categories::-webkit-scrollbar { width: 4px; }
  .block-categories::-webkit-scrollbar-track { background: transparent; }
  .block-categories::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .cat-header {
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--text-muted);
    padding: 10px 6px 4px;
  }

  .palette-block {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    border-radius: 8px;
    margin: 3px 0;
    cursor: grab;
    font-size: 12px;
    font-weight: 500;
    user-select: none;
    transition: all 0.15s;
    border-left: 3px solid transparent;
    background: var(--surface2);
  }
  .palette-block:hover { transform: translateX(3px); filter: brightness(1.15); }
  .palette-block:active { cursor: grabbing; transform: scale(0.97); }
  .palette-block .block-icon { font-size: 14px; width: 18px; text-align: center; flex-shrink: 0; }

  /* ---- CANVAS ---- */
  .canvas-wrap {
    position: relative;
    overflow: hidden;
    background: var(--bg);
    background-image:
      radial-gradient(circle at 50% 0%, rgba(124,92,252,0.06) 0%, transparent 60%),
      linear-gradient(rgba(42,47,90,0.3) 1px, transparent 1px),
      linear-gradient(90deg, rgba(42,47,90,0.3) 1px, transparent 1px);
    background-size: 100% 100%, 30px 30px, 30px 30px;
    cursor: grab;
  }
  .canvas-wrap:active { cursor: grabbing; }

  .canvas {
    position: absolute;
    top: 0; left: 0;
    min-width: 100%;
    min-height: 100%;
    overflow: visible;
    transform-origin: 0 0;
    will-change: transform;
  }

  .canvas-hint {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: var(--text-muted);
    pointer-events: none;
    transition: opacity 0.3s;
  }
  .canvas-hint .hint-icon { font-size: 48px; margin-bottom: 12px; display: block; }
  .canvas-hint p { font-size: 14px; }

  /* ---- BLOCK ON CANVAS ---- */
  .block-node {
    position: absolute;
    min-width: 180px;
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    cursor: move;
    user-select: none;
    z-index: 10;
    transition: box-shadow 0.15s;
  }
  .block-node:hover { box-shadow: 0 8px 30px rgba(0,0,0,0.5); z-index: 20; }
  .block-node.dragging { z-index: 100; box-shadow: 0 16px 50px rgba(0,0,0,0.6); }
  .block-node.selected { outline: 2px solid var(--accent2); outline-offset: 2px; }

  .block-header {
    padding: 8px 12px;
    border-radius: 10px 10px 0 0;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    font-weight: 700;
    letter-spacing: 0.3px;
  }
  .block-header .bh-icon { font-size: 14px; }
  .block-header .bh-label { flex: 1; }
  .block-close {
    width: 18px; height: 18px;
    border-radius: 4px;
    border: none;
    background: rgba(0,0,0,0.25);
    color: rgba(255,255,255,0.7);
    cursor: pointer;
    font-size: 11px;
    display: flex; align-items: center; justify-content: center;
    line-height: 1;
    transition: background 0.15s;
  }
  .block-close:hover { background: rgba(255,107,107,0.5); color: white; }

  .block-body {
    padding: 10px 12px;
    background: rgba(13,15,26,0.85);
    border-radius: 0 0 10px 10px;
  }

  .block-field {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 4px 0;
    font-size: 12px;
    color: var(--text-dim);
  }
  .block-field label { white-space: nowrap; font-size: 11px; min-width: 50px; }
  .block-field input, .block-field select {
    flex: 1;
    background: var(--surface3);
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 4px 8px;
    color: var(--text);
    font-size: 11px;
    font-family: 'JetBrains Mono', monospace;
    outline: none;
    transition: border-color 0.15s;
    min-width: 0;
  }
  .block-field input:focus, .block-field select:focus { border-color: var(--accent); }

  /* connector ports ‚Äî full-width ribbon connectors */
  .block-connector {
    position: absolute;
    left: -1px;
    right: -1px;
    width: auto;
    transform: none;
    height: 12px;
    border-radius: 3px 3px 0 0;
    background: linear-gradient(180deg, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.04) 100%);
    border: 1.5px solid var(--border);
    cursor: grab;
    transition: background 0.1s, border-color 0.1s, box-shadow 0.1s;
    z-index: 6;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
  }
  /* grip lines */
  .block-connector::before,
  .block-connector::after {
    content: '';
    display: block;
    width: 18px;
    height: 2px;
    border-radius: 1px;
    background: rgba(255,255,255,0.15);
    flex-shrink: 0;
  }
  .block-connector:hover {
    border-color: var(--accent2);
    background: linear-gradient(180deg, rgba(0,229,255,0.2) 0%, rgba(0,229,255,0.06) 100%);
    box-shadow: 0 0 10px rgba(0,229,255,0.35);
    cursor: grab;
  }
  .block-connector:hover::before,
  .block-connector:hover::after { background: rgba(0,229,255,0.5); }
  .block-connector.top    { top: -13px; border-radius: 3px 3px 0 0; }
  .block-connector.bottom { bottom: -13px; border-radius: 0 0 3px 3px; }

  /* Body port ‚Äî right side of container blocks */
  .block-connector.body-port {
    left: auto;
    right: -20px;
    top: 50%;
    transform: translateY(-50%);
    width: 18px;
    height: 18px;
    border-radius: 4px;
    border-color: var(--accent4);
    background: var(--surface3);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
  }
  .block-connector.body-port:hover {
    border-color: var(--accent4);
    background: var(--accent4);
    transform: translateY(-50%) scale(1.15);
  }
  .body-port-label {
    font-size: 8px;
    font-weight: 700;
    color: var(--accent4);
    font-family: 'JetBrains Mono', monospace;
    pointer-events: none;
    line-height: 1;
  }
  .block-connector.body-port:hover .body-port-label { color: var(--bg); }
  .block-connector.body-port.port-selected { border-color: var(--accent4) !important; background: var(--accent4) !important; }

  /* Body wire ‚Äî distinct color from flow wire */
  .body-line {
    stroke: var(--accent4) !important;
    stroke-dasharray: 6 3;
  }

  /* connected line */
  svg.connections {
    position: absolute;
    top: 0; left: 0;
    width: 8000px;
    height: 8000px;
    pointer-events: none;
    z-index: 5;
    overflow: visible;
  }
  svg.connections .wire-hit {
    pointer-events: stroke;
    cursor: pointer;
  }
  .conn-line {
    stroke: var(--accent);
    stroke-width: 2;
    fill: none;
    stroke-dasharray: 5 3;
    animation: dashflow 1s linear infinite;
    opacity: 0.6;
  }
  @keyframes dashflow { to { stroke-dashoffset: -8; } }

  /* ---- RIGHT PANEL ---- */
  .right-panel {
    display: flex;
    flex-direction: column;
    border-left: 1px solid var(--border);
    background: var(--surface);
    overflow: hidden;
  }

  .panel-tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .panel-tab {
    flex: 1;
    padding: 12px 8px;
    text-align: center;
    font-size: 11px;
    font-weight: 700;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.15s;
    border-bottom: 2px solid transparent;
    letter-spacing: 0.5px;
    text-transform: uppercase;
  }
  .panel-tab.active { color: var(--accent2); border-bottom-color: var(--accent2); }
  .panel-tab:hover:not(.active) { color: var(--text); }

  .panel-content { display: none; flex: 1; flex-direction: column; overflow: hidden; }
  .panel-content.active { display: flex; }

  /* Code editor */
  .code-area {
    flex: 1;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  .code-toolbar {
    padding: 8px 12px;
    background: var(--surface2);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 8px;
    flex-shrink: 0;
  }
  .code-toolbar span {
    font-size: 11px;
    color: var(--text-dim);
    font-family: 'JetBrains Mono', monospace;
  }

  /* Layered editor: syntax-highlighted pre behind transparent textarea */
  .code-editor-wrap {
    flex: 1;
    position: relative;
    overflow: hidden;
  }
  .code-highlight-layer,
  .code-textarea {
    position: absolute;
    inset: 0;
    margin: 0;
    padding: 16px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    line-height: 1.7;
    tab-size: 4;
    white-space: pre;
    overflow: auto;
    word-wrap: normal;
    border: none;
    outline: none;
    border-radius: 0;
    box-sizing: border-box;
  }
  .code-highlight-layer {
    color: var(--text);
    background: var(--bg);
    pointer-events: none;
    z-index: 1;
    overflow: hidden; /* scroll synced from textarea */
  }
  .code-textarea {
    color: transparent;
    background: transparent;
    caret-color: var(--accent2);
    z-index: 2;
    resize: none;
    width: 100%;
    height: 100%;
  }
  .code-textarea::selection { background: rgba(124,92,252,0.35); }
  .code-textarea::-webkit-scrollbar { width: 4px; height: 4px; }
  .code-textarea::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
  .code-textarea::-webkit-scrollbar-track { background: transparent; }

  /* standalone pre (used in mobile overlay / output) */
  pre {
    flex: 1;
    overflow: auto;
    padding: 16px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    line-height: 1.7;
    color: var(--text);
    background: var(--bg);
    margin: 0;
    white-space: pre;
  }
  pre::-webkit-scrollbar { width: 4px; height: 4px; }
  pre::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  /* syntax highlight */
  .kw { color: #c792ea; }
  .fn { color: #82aaff; }
  .st { color: #c3e88d; }
  .nm { color: var(--accent4); }
  .cm { color: var(--text-muted); font-style: italic; }
  .op { color: var(--accent3); }
  .bltn { color: var(--accent2); }

  /* Output */
  .output-area {
    flex: 1;
    overflow: auto;
    padding: 12px;
    background: var(--bg);
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    line-height: 1.6;
  }
  .output-area::-webkit-scrollbar { width: 4px; }
  .output-area::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
  .output-line { padding: 2px 0; white-space: pre-wrap; word-break: break-all; }
  .output-line.info { color: var(--text-dim); }
  .output-line.ok { color: var(--accent5); }
  .output-line.err { color: var(--accent3); }
  .output-line.out { color: var(--text); }

  /* Variables panel */
  .vars-area {
    flex: 1;
    overflow-y: auto;
    padding: 12px;
  }
  .var-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 10px;
    background: var(--surface2);
    border-radius: 8px;
    margin-bottom: 6px;
    border: 1px solid var(--border);
  }
  .var-name { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--accent4); flex: 1; }
  .var-val { font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--accent5); max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .var-type { font-size: 10px; color: var(--text-muted); background: var(--surface3); padding: 2px 6px; border-radius: 4px; }
  .vars-empty { color: var(--text-muted); font-size: 13px; text-align: center; padding: 30px; }

  /* Canvas toolbar */
  .canvas-toolbar {
    position: absolute;
    top: 12px;
    right: 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    z-index: 50;
  }
  .ct-btn {
    width: 36px; height: 36px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text-dim);
    cursor: pointer;
    font-size: 16px;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.15s;
  }
  .ct-btn:hover { background: var(--surface3); color: var(--text); border-color: var(--accent); }

  /* Mini-map */
  .minimap {
    position: absolute;
    bottom: 12px;
    right: 12px;
    width: 120px;
    height: 80px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    z-index: 50;
    opacity: 0.7;
  }

  /* Block connection arrows */
  .arrow-connector {
    position: absolute;
    pointer-events: none;
    z-index: 15;
  }

  /* Tooltip */
  .tooltip {
    position: fixed;
    background: var(--surface3);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 11px;
    color: var(--text);
    pointer-events: none;
    z-index: 9999;
    display: none;
    max-width: 200px;
  }

  /* Floating input prompt */
  .floating-prompt {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    z-index: 10100;
    display: none;
    min-width: 300px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  }
  .floating-prompt h3 { font-size: 14px; margin-bottom: 12px; color: var(--accent); }
  .floating-prompt input {
    width: 100%;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 10px;
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    outline: none;
    margin-bottom: 10px;
  }
  .floating-prompt input:focus { border-color: var(--accent); }
  .fp-btns { display: flex; gap: 8px; justify-content: flex-end; }

  /* Backdrop - dimming layer only, pointer-events off so drawer content is always tappable */
  .backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 175;
    display: none;
    pointer-events: none;
  }

  /* Status bar */
  .statusbar {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 24px;
    background: var(--surface);
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 12px;
    gap: 16px;
    font-size: 11px;
    color: var(--text-muted);
    z-index: 50;
  }
  .status-item span { color: var(--text-dim); }

  @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
  .block-node { animation: fadeIn 0.15s ease; }

  /* Click-to-connect wiring mode */
  .canvas-wrap.wiring .block-node { cursor: crosshair; }
  .canvas-wrap.wiring .block-header { cursor: crosshair; }

  /* Selected port (drag start or first click) */
  .block-connector.port-selected {
    border-color: var(--accent2) !important;
    background: linear-gradient(180deg, rgba(0,229,255,0.35) 0%, rgba(0,229,255,0.12) 100%) !important;
    box-shadow: 0 0 12px rgba(0,229,255,0.5) !important;
    animation: portPulse 0.9s ease-in-out infinite;
  }
  .block-connector.port-selected::before,
  .block-connector.port-selected::after { background: rgba(0,229,255,0.7); }
  /* Snap target highlight */
  .block-connector.snap-highlight {
    border-color: var(--accent2) !important;
    background: linear-gradient(180deg, rgba(0,229,255,0.45) 0%, rgba(0,229,255,0.18) 100%) !important;
    box-shadow: 0 0 18px rgba(0,229,255,0.65) !important;
    animation: snapPulse 0.35s ease-in-out infinite alternate;
  }
  .block-connector.snap-highlight::before,
  .block-connector.snap-highlight::after { background: var(--accent2); }
  .block-connector.body-port.port-selected  { transform: translateY(-50%) scale(1.2) !important; }
  .block-connector.body-port.snap-highlight { transform: translateY(-50%) scale(1.35) !important; }
  @keyframes snapPulse {
    from { box-shadow: 0 0 8px rgba(0,229,255,0.3); }
    to   { box-shadow: 0 0 22px rgba(0,229,255,0.7); }
  }
  @keyframes portPulse {
    0%, 100% { box-shadow: 0 0 0 3px rgba(0,229,255,0.3), 0 0 12px var(--accent2); }
    50%       { box-shadow: 0 0 0 6px rgba(0,229,255,0.1), 0 0 22px var(--accent2); }
  }

  /* Valid target port while wiring */
  .canvas-wrap.wiring .block-connector:not(.port-selected) {
    border-color: var(--accent2);
    opacity: 1;
    transform: translateX(-50%) scale(1.3);
    cursor: pointer;
  }

  /* Cancel wire button */
  .wire-cancel-btn {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--accent3);
    color: white;
    border: none;
    border-radius: 24px;
    padding: 10px 22px;
    font-family: 'Rubik', sans-serif;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    z-index: 300;
    display: none;
    align-items: center;
    gap: 8px;
    box-shadow: 0 4px 20px rgba(255,107,107,0.45);
    animation: fadeIn 0.15s ease;
    -webkit-tap-highlight-color: transparent;
  }
  .wire-cancel-btn:active { transform: translateX(-50%) scale(0.95); }
  /* On desktop, position it lower so it doesn't cover nodes */
  @media (min-width: 769px) {
    .wire-cancel-btn { bottom: 36px; }
  }

  /* ============================================================
     MOBILE STYLES
  ============================================================ */

  /* Mobile bottom nav */
  .mobile-nav {
    display: none;
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 60px;
    background: var(--surface);
    border-top: 1px solid var(--border);
    z-index: 200;
    align-items: stretch;
  }
  .mobile-nav-btn {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 3px;
    background: none;
    border: none;
    color: var(--text-dim);
    font-family: 'Rubik', sans-serif;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 0.3px;
    text-transform: uppercase;
    -webkit-tap-highlight-color: transparent;
  }
  .mobile-nav-btn .nav-icon { font-size: 20px; line-height: 1; }
  .mobile-nav-btn.active { color: var(--accent); }
  .mobile-nav-btn:active { background: var(--surface2); }

  /* Mobile run FAB */
  .mobile-fab {
    display: none;
    position: fixed;
    bottom: 76px;
    right: 16px;
    width: 52px; height: 52px;
    border-radius: 50%;
    background: var(--accent);
    border: none;
    color: white;
    font-size: 22px;
    cursor: pointer;
    z-index: 200;
    box-shadow: 0 4px 20px rgba(124,92,252,0.5);
    align-items: center;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .mobile-fab:active { transform: scale(0.92); box-shadow: 0 2px 10px rgba(124,92,252,0.4); }

  /* Slide-up drawer (blocks palette on mobile) */
  .mobile-drawer {
    display: none;
    position: fixed;
    bottom: 60px; left: 0; right: 0;
    background: var(--surface);
    border-top: 1px solid var(--border);
    border-radius: 16px 16px 0 0;
    z-index: 190;
    flex-direction: column;
    max-height: 70vh;
    transform: translateY(100%);
    transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
  }
  .mobile-drawer.open { transform: translateY(0); }
  .drawer-handle {
    width: 100%;
    padding: 14px 0 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    flex-shrink: 0;
  }
  .drawer-handle::after {
    content: '';
    display: block;
    width: 40px; height: 4px;
    background: var(--border);
    border-radius: 2px;
  }
  .drawer-title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-dim);
    text-align: center;
    padding: 0 0 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
    flex-shrink: 0;
  }
  .drawer-search {
    margin: 0 12px 8px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 9px 12px;
    color: var(--text);
    font-size: 14px;
    font-family: 'Rubik', sans-serif;
    outline: none;
    flex-shrink: 0;
  }
  .drawer-search:focus { border-color: var(--accent); }
  .drawer-blocks { overflow-y: auto; flex: 1; padding: 4px 12px 12px; }
  .drawer-blocks::-webkit-scrollbar { display: none; }

  /* Mobile panel overlay (code/output/vars on mobile) */
  .mobile-panel-overlay {
    display: none;
    position: fixed;
    inset: 0;
    bottom: 60px;
    background: var(--surface);
    z-index: 180;
    flex-direction: column;
    transform: translateY(100%);
    transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
  }
  .mobile-panel-overlay.open { transform: translateY(0); }
  .mobile-panel-header {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    gap: 12px;
    flex-shrink: 0;
  }
  .mobile-panel-title { font-size: 15px; font-weight: 700; flex: 1; }
  .mobile-close-btn {
    background: var(--surface3);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 8px;
    padding: 6px 12px;
    font-size: 13px;
    cursor: pointer;
    font-family: 'Rubik', sans-serif;
    font-weight: 600;
  }

  /* Mobile block cards in drawer - bigger tap targets */
  @media (max-width: 768px) {
    header {
      padding: 0 12px;
      height: 50px;
    }
    .logo { font-size: 15px; }
    .logo-snake { font-size: 18px; }
    .project-name { display: none; }
    .header-btns .btn-secondary { display: none; }
    .header-btns .btn-primary { display: none; } /* replaced by FAB */
    .app {
      grid-template-columns: 1fr;
      grid-template-rows: 1fr;
      height: calc(100vh - 50px);
    }
    .sidebar { display: none; }
    .right-panel { display: none; }
    .canvas-wrap { grid-column: 1; grid-row: 1; padding-bottom: 60px; }
    .statusbar { bottom: 0; display: none; }
    .canvas-toolbar { top: 8px; right: 8px; }
    .ct-btn { width: 40px; height: 40px; font-size: 18px; }
    .mobile-nav { display: flex; }
    .mobile-fab { display: flex; }
    .mobile-drawer { display: flex; }
    .mobile-panel-overlay { display: flex; }
    /* Bigger block inputs on touch */
    .block-field input, .block-field select {
      padding: 7px 10px;
      font-size: 13px;
    }
    .block-field label { font-size: 12px; }
    .block-header { padding: 10px 14px; font-size: 13px; }
    .block-close { width: 24px; height: 24px; font-size: 14px; }
    .block-node { min-width: 200px; }
    /* Canvas hint */
    .canvas-hint p { font-size: 13px; }
    .canvas-hint .hint-icon { font-size: 36px; }
    /* Palette blocks in drawer */
    .drawer-blocks .palette-block {
      padding: 12px 14px;
      font-size: 14px;
      margin: 5px 0;
      border-radius: 10px;
    }
    .drawer-blocks .palette-block .block-icon { font-size: 18px; }
    .drawer-blocks .cat-header { font-size: 11px; padding: 14px 6px 5px; }
    /* code preview */
    pre { font-size: 13px; }
    .output-area { font-size: 13px; }
  }

  /* Extra small screens */
  @media (max-width: 380px) {
    .mobile-nav-btn { font-size: 9px; }
    .mobile-nav-btn .nav-icon { font-size: 18px; }
    .ct-btn { width: 36px; height: 36px; }
  }

  /* Pinch-zoom visual feedback */
  .canvas-wrap.pinching { cursor: zoom-in; }

  /* Parse flash */
  @keyframes parseFlash {
    0%   { box-shadow: inset 0 0 0 3px var(--accent); }
    100% { box-shadow: inset 0 0 0 0 var(--accent); }
  }
  .canvas-wrap.parse-flash { animation: parseFlash 0.45s ease; }

  /* Touch drag ghost */
  .touch-ghost {
    position: fixed;
    z-index: 9000;
    pointer-events: none;
    opacity: 0.85;
    border-radius: 10px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.5);
    transform: scale(1.05);
    transition: none;
    background: var(--surface2);
    padding: 10px 14px;
    font-family: 'Rubik', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 8px;
    border-left: 3px solid transparent;
  }
  /* ---- Q MENU ---- */
  .q-menu {
    position: fixed;
    inset: 0;
    background: rgba(10,12,20,0.88);
    backdrop-filter: blur(6px);
    z-index: 9000;
    display: flex;
    flex-direction: column;
    font-family: 'Rubik', sans-serif;
  }
  .q-menu-cats {
    display: flex;
    gap: 2px;
    padding: 10px 14px 0;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .q-cat-tab {
    padding: 7px 16px;
    border-radius: 6px 6px 0 0;
    font-size: 12px;
    font-weight: 700;
    letter-spacing: 0.4px;
    cursor: pointer;
    color: var(--text-dim);
    border: 1px solid transparent;
    border-bottom: none;
    user-select: none;
  }
  .q-cat-tab:hover { color: var(--text); background: rgba(255,255,255,0.05); }
  .q-cat-tab.active { color: var(--text); background: var(--surface2); border-color: var(--border); }
  .q-menu-body {
    display: flex;
    flex: 1;
    overflow: hidden;
  }
  .q-menu-subcats {
    width: 160px;
    flex-shrink: 0;
    border-right: 1px solid var(--border);
    padding: 10px 0;
    overflow-y: auto;
  }
  .q-subcat {
    padding: 8px 16px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    color: var(--text-dim);
    border-left: 3px solid transparent;
    user-select: none;
  }
  .q-subcat:hover { color: var(--text); background: rgba(255,255,255,0.04); }
  .q-subcat.active { color: var(--text); border-left-color: var(--accent2); background: rgba(0,229,255,0.06); }
  .q-menu-grid {
    flex: 1;
    padding: 16px;
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 10px;
    align-content: start;
  }
  .q-block-card {
    background: var(--surface2);
    border-radius: 10px;
    border-top: 3px solid transparent;
    cursor: grab;
    user-select: none;
    overflow: hidden;
  }
  .q-block-card:hover { box-shadow: 0 0 0 1px rgba(255,255,255,0.12); }
  .q-block-card:active { cursor: grabbing; }
  .q-block-card .block-header { border-radius: 7px 7px 0 0; pointer-events: none; }
  .q-block-card .block-body   { pointer-events: none; }
  .q-block-card .block-connector { display: none; }
  .q-menu-hint {
    text-align: center;
    padding: 6px;
    font-size: 11px;
    color: var(--text-dim);
    border-top: 1px solid var(--border);
    flex-shrink: 0;
  }

  /* proximity auto-connect highlight */
  .block-node.proximity-snap { outline: 2px solid var(--accent2); outline-offset: 3px; box-shadow: 0 0 20px rgba(0,229,255,0.35); }

</style>
</head>
<body>

<header>
  <div class="logo">
    <span class="logo-snake">üêç</span>
    SnakeScratch
  </div>
  <input class="project-name" id="projectName" value="my_project.py" title="Click to rename" />
  <div class="header-btns">
    <button class="btn btn-secondary" onclick="clearCanvas()">üóë Clear</button>
    <button class="btn btn-secondary" onclick="loadExample()">üì¶ Examples</button>
    <button class="btn btn-secondary" onclick="exportCode()">üíæ Export .py</button>
    <button class="btn btn-primary" onclick="runCode()">‚ñ∂ Run</button>
  </div>
</header>

<div class="app">
  <!-- SIDEBAR -->
  <div class="sidebar">
    <div class="sidebar-tabs">
      <div class="sidebar-tab active" onclick="switchSideTab('blocks', this)">Blocks</div>
      <div class="sidebar-tab" onclick="switchSideTab('search', this)">Search</div>
    </div>
    <div id="blocksPanel" class="block-categories">
      <!-- Populated by JS -->
    </div>
    <div id="searchPanel" class="block-categories" style="display:none;">
      <input id="blockSearch" oninput="filterBlocks(this.value)" placeholder="Search blocks..." style="width:100%;background:var(--surface2);border:1px solid var(--border);border-radius:6px;padding:8px 10px;color:var(--text);font-size:12px;outline:none;margin-bottom:8px;font-family:Rubik,sans-serif;">
      <div id="searchResults"></div>
    </div>
  </div>

  <!-- CANVAS -->
  <div class="canvas-wrap" id="canvasWrap">
    <div class="canvas" id="canvas">
      <svg class="connections" id="svgLayer"></svg>
      <div class="canvas-hint" id="canvasHint">
        <span class="hint-icon">üß±</span>
        <p id="canvasHintText">Drag blocks from the left panel<br>to start building your program</p>
      </div>
    </div>

    <div class="canvas-toolbar">
      <button class="ct-btn" title="Zoom In" onclick="zoomIn()">+</button>
      <button class="ct-btn" title="Zoom Out" onclick="zoomOut()">‚àí</button>
      <button class="ct-btn" title="Reset View" onclick="resetView()">‚ä°</button>
      <button class="ct-btn" title="Auto-arrange" onclick="autoArrange()">‚ö°</button>
    </div>

    <div class="statusbar">
      <span class="status-item">Blocks: <span id="blockCount">0</span></span>
      <span class="status-item">Lines: <span id="lineCount">0</span></span>
      <span class="status-item" id="statusMsg">Ready</span>
    </div>
  </div>

  <!-- RIGHT PANEL -->
  <div class="right-panel">
    <div class="panel-tabs">
      <div class="panel-tab active" onclick="switchTab('code', this)">Code</div>
      <div class="panel-tab" onclick="switchTab('output', this)">Output</div>
      <div class="panel-tab" onclick="switchTab('vars', this)">Variables</div>
    </div>

    <div class="panel-content active" id="tab-code">
      <div class="code-area">
        <div class="code-toolbar">
          <span id="codeStats">0 lines ¬∑ 0 chars</span>
          <button class="btn btn-secondary" style="margin-left:auto;padding:4px 10px;font-size:11px;" onclick="copyCode()">Copy</button>
          <button class="btn btn-primary" style="padding:4px 10px;font-size:11px;" onclick="parseCodeToCanvas()" title="Parse the code and rebuild the canvas">‚ü≥ To Canvas</button>
        </div>
        <div class="code-editor-wrap" id="codeEditorWrap">
          <pre class="code-highlight-layer" id="codeHighlight" aria-hidden="true"></pre>
          <textarea class="code-textarea" id="codeTextarea" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="# Paste or type Python code here&#10;# then click ‚ü≥ To Canvas"></textarea>
        </div>
      </div>
    </div>

    <div class="panel-content" id="tab-output">
      <div class="code-toolbar" style="justify-content:space-between;">
        <span style="font-size:11px;color:var(--text-dim);font-family:'JetBrains Mono',monospace;">Output Console</span>
        <button class="btn btn-secondary" style="padding:4px 10px;font-size:11px;" onclick="clearOutput()">Clear</button>
      </div>
      <div class="output-area" id="outputArea">
        <div class="output-line info">// Console output will appear here after running your code</div>
      </div>
    </div>

    <div class="panel-content" id="tab-vars">
      <div class="code-toolbar">
        <span style="font-size:11px;color:var(--text-dim);font-family:'JetBrains Mono',monospace;">Variable Inspector</span>
      </div>
      <div class="vars-area" id="varsArea">
        <div class="vars-empty">No variables defined yet</div>
      </div>
    </div>
  </div>
</div>

<!-- MOBILE BOTTOM NAV -->
<nav class="mobile-nav" id="mobileNav">
  <button class="mobile-nav-btn active" id="navCanvas" onclick="mobileNav('canvas')">
    <span class="nav-icon">üñº</span>Canvas
  </button>
  <button class="mobile-nav-btn" id="navBlocks" onclick="mobileNav('blocks')">
    <span class="nav-icon">üß±</span>Blocks
  </button>
  <button class="mobile-nav-btn" id="navCode" onclick="mobileNav('code')">
    <span class="nav-icon">üìÑ</span>Code
  </button>
  <button class="mobile-nav-btn" id="navOutput" onclick="mobileNav('output')">
    <span class="nav-icon">üíª</span>Output
  </button>
  <button class="mobile-nav-btn" id="navMore" onclick="mobileNav('more')">
    <span class="nav-icon">‚ãØ</span>More
  </button>
</nav>

<!-- MOBILE FAB (Run) -->
<button class="mobile-fab" id="mobileFab" onclick="runCode()">‚ñ∂</button>

<!-- MOBILE BLOCK DRAWER -->
<div class="mobile-drawer" id="mobileDrawer">
  <div class="drawer-handle" onclick="closeAllMobile(); document.querySelectorAll('.mobile-nav-btn').forEach(b=>b.classList.remove('active')); document.getElementById('navCanvas').classList.add('active');"></div>
  <div class="drawer-title">Add Block</div>
  <input class="drawer-search" id="drawerSearch" placeholder="Search blocks..." oninput="filterDrawerBlocks(this.value)" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <div class="drawer-blocks" id="drawerBlocks"></div>
</div>

<!-- MOBILE CODE/OUTPUT/VARS PANEL -->
<div class="mobile-panel-overlay" id="mobilePanelOverlay">
  <div class="mobile-panel-header">
    <span class="mobile-panel-title" id="mobilePanelTitle">Code</span>
    <button class="mobile-close-btn" onclick="closeMobilePanel()">&#x2715; Close</button>
  </div>
  <div id="mobile-tab-code" style="flex:1;display:flex;flex-direction:column;overflow:hidden;">
    <div class="code-toolbar" style="justify-content:space-between;">
      <span id="mobileCodeStats" style="font-size:11px;color:var(--text-dim);font-family:'JetBrains Mono',monospace;">0 lines</span>
      <button class="btn btn-secondary" style="padding:5px 12px;font-size:12px;" onclick="copyCode()">Copy</button>
    </div>
    <pre id="mobileCodePreview" style="flex:1;overflow:auto;padding:16px;font-family:'JetBrains Mono',monospace;font-size:13px;line-height:1.7;color:var(--text);background:var(--bg);margin:0;white-space:pre;"><span class="cm"># Your code appears here</span></pre>
  </div>
  <div id="mobile-tab-output" style="flex:1;display:none;flex-direction:column;overflow:hidden;">
    <div class="code-toolbar" style="justify-content:space-between;">
      <span style="font-size:11px;color:var(--text-dim);font-family:'JetBrains Mono',monospace;">Console</span>
      <button class="btn btn-secondary" style="padding:5px 12px;font-size:12px;" onclick="clearMobileOutput()">Clear</button>
    </div>
    <div class="output-area" id="mobileOutputArea" style="flex:1;overflow:auto;">
      <div class="output-line info">// Run your program to see output</div>
    </div>
  </div>
  <div id="mobile-tab-vars" style="flex:1;display:none;flex-direction:column;overflow:hidden;">
    <div class="code-toolbar">
      <span style="font-size:11px;color:var(--text-dim);font-family:'JetBrains Mono',monospace;">Variable Inspector</span>
    </div>
    <div class="vars-area" id="mobileVarsArea" style="flex:1;overflow-y:auto;padding:12px;">
      <div class="vars-empty">No variables defined yet</div>
    </div>
  </div>
</div>

<!-- MORE MENU DRAWER -->
<div class="mobile-drawer" id="mobileMoreDrawer" style="z-index:191;">
  <div class="drawer-handle" onclick="closeMobileMore();"></div>
  <div class="drawer-title">Options</div>
  <div style="padding:8px 12px 20px;display:flex;flex-direction:column;gap:10px;">
    <button class="btn btn-secondary" style="padding:14px;font-size:15px;text-align:left;" onclick="loadExample();closeMobileMore();">&#x1F4E6; Load Example</button>
    <button class="btn btn-secondary" style="padding:14px;font-size:15px;text-align:left;" onclick="autoArrange();closeMobileMore();">&#x26A1; Auto-Arrange Blocks</button>
    <button class="btn btn-secondary" style="padding:14px;font-size:15px;text-align:left;" onclick="exportCode();closeMobileMore();">&#x1F4BE; Export .py File</button>
    <button class="btn btn-danger" style="padding:14px;font-size:15px;text-align:left;" onclick="clearCanvas();closeMobileMore();">&#x1F5D1; Clear Canvas</button>
  </div>
</div>

<div class="tooltip" id="tooltip"></div>
<div class="backdrop" id="backdrop" onclick="closePrompt()"></div>
<div class="floating-prompt" id="floatingPrompt">
  <h3 id="promptTitle">Enter value</h3>
  <input id="promptInput" />
  <div class="fp-btns">
    <button class="btn btn-secondary" onclick="closePrompt()">Cancel</button>
    <button class="btn btn-primary" onclick="confirmPrompt()">OK</button>
  </div>
</div>

<!-- Q MENU OVERLAY -->
<div id="qMenu" class="q-menu" style="display:none;">
  <div class="q-menu-cats" id="qMenuCats"></div>
  <div class="q-menu-body">
    <div class="q-menu-subcats" id="qMenuSubcats"></div>
    <div class="q-menu-grid" id="qMenuGrid"></div>
  </div>
  <div class="q-menu-hint">Hold Q ¬∑ release to close ¬∑ drag block to canvas</div>
</div>

<script>
// ============================================================
// BLOCK DEFINITIONS
// ============================================================
const BLOCK_DEFS = [
  // CONTROL
  { id: 'if',       cat: 'control', icon: 'üîÄ', label: 'If / Elif / Else', color: '#7c5cfc', hasBody: true,
    fields: [{ name: 'condition', label: 'if', type: 'text', default: 'x > 0' }],
    code: (f) => `if ${f.condition}:` },
  { id: 'for',      cat: 'control', icon: 'üîÅ', label: 'For Loop', color: '#7c5cfc', hasBody: true,
    fields: [{ name: 'var', label: 'var', type: 'text', default: 'i' }, { name: 'iter', label: 'in', type: 'text', default: 'range(10)' }],
    code: (f) => `for ${f.var} in ${f.iter}:` },
  { id: 'while',    cat: 'control', icon: 'üîÑ', label: 'While Loop', color: '#7c5cfc', hasBody: true,
    fields: [{ name: 'condition', label: 'while', type: 'text', default: 'True' }],
    code: (f) => `while ${f.condition}:` },
  { id: 'break',    cat: 'control', icon: '‚õî', label: 'Break', color: '#7c5cfc',
    fields: [], code: () => 'break' },
  { id: 'continue', cat: 'control', icon: '‚è≠', label: 'Continue', color: '#7c5cfc',
    fields: [], code: () => 'continue' },
  { id: 'pass',     cat: 'control', icon: 'üö∂', label: 'Pass', color: '#7c5cfc',
    fields: [], code: () => 'pass' },
  { id: 'tryexcept',cat: 'control', icon: 'üõ°', label: 'Try / Except', color: '#7c5cfc', hasBody: true,
    fields: [{ name: 'exc', label: 'except', type: 'text', default: 'Exception as e' }],
    code: (f) => `try:\n    pass\nexcept ${f.exc}:` },
  { id: 'withopen', cat: 'control', icon: 'üìÇ', label: 'With / Open', color: '#7c5cfc', hasBody: true,
    fields: [{ name: 'file', label: 'file', type: 'text', default: "'data.txt'" }, { name: 'mode', label: 'mode', type: 'text', default: "'r'" }, { name: 'var', label: 'as', type: 'text', default: 'f' }],
    code: (f) => `with open(${f.file}, ${f.mode}) as ${f.var}:` },

  // DATA
  { id: 'assign',   cat: 'data', icon: 'üì¶', label: 'Assign Variable', color: '#00b4d8',
    fields: [{ name: 'name', label: 'var', type: 'text', default: 'x' }, { name: 'value', label: '=', type: 'text', default: '0' }],
    code: (f) => `${f.name} = ${f.value}` },
  { id: 'augassign',cat: 'data', icon: '‚ûï', label: 'Update Variable', color: '#00b4d8',
    fields: [{ name: 'name', label: 'var', type: 'text', default: 'x' }, { name: 'op', label: 'op', type: 'select', options: ['+=', '-=', '*=', '/=', '//=', '%=', '**='], default: '+=' }, { name: 'value', label: 'val', type: 'text', default: '1' }],
    code: (f) => `${f.name} ${f.op} ${f.value}` },
  { id: 'delete',   cat: 'data', icon: 'üóë', label: 'Delete Variable', color: '#00b4d8',
    fields: [{ name: 'name', label: 'del', type: 'text', default: 'x' }],
    code: (f) => `del ${f.name}` },

  // MATH
  { id: 'mathexpr', cat: 'math', icon: 'üî¢', label: 'Math Expression', color: '#06d6a0',
    fields: [{ name: 'result', label: 'result', type: 'text', default: 'result' }, { name: 'expr', label: '=', type: 'text', default: 'math.sqrt(16)' }],
    code: (f) => `${f.result} = ${f.expr}` },
  { id: 'importmath',cat:'math', icon:'üìê', label:'Import Math', color:'#06d6a0',
    fields:[], code: () => 'import math' },
  { id: 'random',   cat: 'math', icon: 'üé≤', label: 'Random Number', color: '#06d6a0',
    fields: [{ name: 'var', label: 'var', type: 'text', default: 'num' }, { name: 'lo', label: 'from', type: 'text', default: '1' }, { name: 'hi', label: 'to', type: 'text', default: '100' }],
    code: (f) => `${f.var} = random.randint(${f.lo}, ${f.hi})` },
  { id: 'importrandom',cat:'math',icon:'üé∞',label:'Import Random',color:'#06d6a0',
    fields:[], code: () => 'import random' },

  // LOGIC
  { id: 'andor',    cat: 'logic', icon: 'üîó', label: 'And / Or Expr', color: '#ff6b6b',
    fields: [{ name: 'res', label: 'result', type: 'text', default: 'result' }, { name: 'a', label: 'a', type: 'text', default: 'x > 0' }, { name: 'op', label: 'op', type: 'select', options: ['and', 'or', 'not'], default: 'and' }, { name: 'b', label: 'b', type: 'text', default: 'y < 10' }],
    code: (f) => f.op === 'not' ? `${f.res} = not (${f.a})` : `${f.res} = (${f.a}) ${f.op} (${f.b})` },
  { id: 'compare',  cat: 'logic', icon: '‚öñ', label: 'Compare', color: '#ff6b6b',
    fields: [{ name: 'res', label: 'result', type: 'text', default: 'result' }, { name: 'a', label: 'a', type: 'text', default: 'x' }, { name: 'op', label: 'op', type: 'select', options: ['==', '!=', '<', '>', '<=', '>=', 'in', 'not in', 'is', 'is not'], default: '==' }, { name: 'b', label: 'b', type: 'text', default: '0' }],
    code: (f) => `${f.res} = ${f.a} ${f.op} ${f.b}` },

  // FUNCTIONS
  { id: 'defn',     cat: 'function', icon: 'üß©', label: 'Define Function', color: '#ffd166', hasBody: true,
    fields: [{ name: 'name', label: 'def', type: 'text', default: 'my_func' }, { name: 'args', label: 'args', type: 'text', default: 'x, y' }],
    code: (f) => `def ${f.name}(${f.args}):` },
  { id: 'return',   cat: 'function', icon: '‚Ü©', label: 'Return', color: '#ffd166',
    fields: [{ name: 'value', label: 'return', type: 'text', default: 'result' }],
    code: (f) => `return ${f.value}` },
  { id: 'call',     cat: 'function', icon: 'üìû', label: 'Call Function', color: '#ffd166',
    fields: [{ name: 'result', label: 'result', type: 'text', default: 'result' }, { name: 'name', label: 'func', type: 'text', default: 'my_func' }, { name: 'args', label: 'args', type: 'text', default: 'x, y' }],
    code: (f) => `${f.result} = ${f.name}(${f.args})` },
  { id: 'lambda',   cat: 'function', icon: 'Œª', label: 'Lambda', color: '#ffd166',
    fields: [{ name: 'var', label: 'var', type: 'text', default: 'fn' }, { name: 'args', label: 'args', type: 'text', default: 'x' }, { name: 'expr', label: 'expr', type: 'text', default: 'x * 2' }],
    code: (f) => `${f.var} = lambda ${f.args}: ${f.expr}` },

  // I/O
  { id: 'print',    cat: 'io', icon: 'üñ®', label: 'Print', color: '#ff9f1c',
    fields: [{ name: 'value', label: 'print', type: 'text', default: '"Hello, World!"' }],
    code: (f) => `print(${f.value})` },
  { id: 'input',    cat: 'io', icon: '‚å®', label: 'Input', color: '#ff9f1c',
    fields: [{ name: 'var', label: 'var', type: 'text', default: 'name' }, { name: 'prompt', label: 'prompt', type: 'text', default: '"Enter value: "' }],
    code: (f) => `${f.var} = input(${f.prompt})` },
  { id: 'filewrite',cat: 'io', icon: '‚úç', label: 'Write File', color: '#ff9f1c',
    fields: [{ name: 'file', label: 'file', type: 'text', default: '"output.txt"' }, { name: 'content', label: 'content', type: 'text', default: 'data' }],
    code: (f) => `with open(${f.file}, 'w') as f:\n    f.write(${f.content})` },

  // LISTS
  { id: 'listcreate', cat: 'list', icon: 'üìã', label: 'Create List', color: '#c77dff',
    fields: [{ name: 'name', label: 'list', type: 'text', default: 'my_list' }, { name: 'items', label: 'items', type: 'text', default: '1, 2, 3' }],
    code: (f) => `${f.name} = [${f.items}]` },
  { id: 'listappend',cat:'list',icon:'‚ûï',label:'Append to List',color:'#c77dff',
    fields:[{name:'list',label:'list',type:'text',default:'my_list'},{name:'item',label:'item',type:'text',default:'value'}],
    code:(f)=>`${f.list}.append(${f.item})`},
  { id: 'listpop',  cat: 'list', icon: '‚ûñ', label: 'Pop from List', color: '#c77dff',
    fields: [{ name: 'var', label: 'var', type: 'text', default: 'item' }, { name: 'list', label: 'list', type: 'text', default: 'my_list' }],
    code: (f) => `${f.var} = ${f.list}.pop()` },
  { id: 'listcomp', cat: 'list', icon: '‚ö°', label: 'List Comprehension', color: '#c77dff',
    fields: [{ name: 'result', label: 'result', type: 'text', default: 'squares' }, { name: 'expr', label: 'expr', type: 'text', default: 'x**2' }, { name: 'var', label: 'for', type: 'text', default: 'x' }, { name: 'iter', label: 'in', type: 'text', default: 'range(10)' }],
    code: (f) => `${f.result} = [${f.expr} for ${f.var} in ${f.iter}]` },
  { id: 'dictcreate',cat:'list',icon:'üìñ',label:'Create Dict',color:'#c77dff',
    fields:[{name:'name',label:'dict',type:'text',default:'my_dict'},{name:'items',label:'items',type:'text',default:'"key": "value"'}],
    code:(f)=>`${f.name} = {${f.items}}`},

  // STRINGS
  { id: 'fstring',  cat: 'string', icon: 'üí¨', label: 'F-String', color: '#43aa8b',
    fields: [{ name: 'var', label: 'var', type: 'text', default: 'msg' }, { name: 'tmpl', label: 'f""', type: 'text', default: 'Hello {name}!' }],
    code: (f) => `${f.var} = f"${f.tmpl}"` },
  { id: 'strsplit', cat: 'string', icon: '‚úÇ', label: 'Split String', color: '#43aa8b',
    fields: [{ name: 'result', label: 'result', type: 'text', default: 'parts' }, { name: 'string', label: 'str', type: 'text', default: 'text' }, { name: 'sep', label: 'sep', type: 'text', default: '","' }],
    code: (f) => `${f.result} = ${f.string}.split(${f.sep})` },
  { id: 'strjoin',  cat: 'string', icon: 'üîó', label: 'Join Strings', color: '#43aa8b',
    fields: [{ name: 'result', label: 'result', type: 'text', default: 'text' }, { name: 'sep', label: 'sep', type: 'text', default: '", "' }, { name: 'iter', label: 'list', type: 'text', default: 'words' }],
    code: (f) => `${f.result} = ${f.sep}.join(${f.iter})` },
  { id: 'strformat',cat:'string',icon:'üé®',label:'Format String',color:'#43aa8b',
    fields:[{name:'result',label:'result',type:'text',default:'msg'},{name:'tmpl',label:'tmpl',type:'text',default:'"Hello, {}!"'},{name:'args',label:'args',type:'text',default:'name'}],
    code:(f)=>`${f.result} = ${f.tmpl}.format(${f.args})`},
  { id: 'comment',  cat: 'string', icon: 'üí≠', label: 'Comment', color: '#43aa8b',
    fields: [{ name: 'text', label: '#', type: 'text', default: 'This is a comment' }],
    code: (f) => `# ${f.text}` },
  { id: 'import',   cat: 'string', icon: 'üì¶', label: 'Import Module', color: '#43aa8b',
    fields: [{ name: 'module', label: 'import', type: 'text', default: 'os' }, { name: 'alias', label: 'as', type: 'text', default: '' }],
    code: (f) => f.alias ? `import ${f.module} as ${f.alias}` : `import ${f.module}` },
];

const CAT_META = {
  control:  { label: 'Control Flow',  color: '#7c5cfc' },
  data:     { label: 'Data / Variables', color: '#00b4d8' },
  math:     { label: 'Math',          color: '#06d6a0' },
  logic:    { label: 'Logic',         color: '#ff6b6b' },
  function: { label: 'Functions',     color: '#ffd166' },
  io:       { label: 'Input / Output',color: '#ff9f1c' },
  list:     { label: 'Lists & Dicts', color: '#c77dff' },
  string:   { label: 'Strings',       color: '#43aa8b' },
};

// ============================================================
// STATE
// ============================================================
let blockNodes = []; // { id, defId, x, y, fields, el }
let connections = []; // { from, to } node ids
let nextId = 1;
let zoom = 1;
let panX = 0, panY = 0;
let draggingBlock = null;
let dragOffset = { x: 0, y: 0 };
let selectedBlock = null;

// ============================================================
// SIDEBAR INIT
// ============================================================
function buildPalette() {
  const container = document.getElementById('blocksPanel');
  container.innerHTML = '';
  const cats = [...new Set(BLOCK_DEFS.map(b => b.cat))];
  cats.forEach(cat => {
    const meta = CAT_META[cat];
    const catHeader = document.createElement('div');
    catHeader.className = 'cat-header';
    catHeader.textContent = meta.label;
    catHeader.style.color = meta.color;
    container.appendChild(catHeader);

    BLOCK_DEFS.filter(b => b.cat === cat).forEach(def => {
      const el = document.createElement('div');
      el.className = 'palette-block';
      el.style.borderLeftColor = def.color;
      el.draggable = true;
      el.innerHTML = `<span class="block-icon">${def.icon}</span><span>${def.label}</span>`;
      el.title = def.label;
      el.addEventListener('dragstart', e => {
        e.dataTransfer.setData('defId', def.id);
      });
      el.addEventListener('dblclick', () => addBlockToCenter(def.id));
      container.appendChild(el);
    });
  });
}

function filterBlocks(query) {
  const container = document.getElementById('searchResults');
  container.innerHTML = '';
  if (!query) return;
  const q = query.toLowerCase();
  BLOCK_DEFS.filter(b => b.label.toLowerCase().includes(q) || b.cat.includes(q)).forEach(def => {
    const el = document.createElement('div');
    el.className = 'palette-block';
    el.style.borderLeftColor = def.color;
    el.draggable = true;
    el.innerHTML = `<span class="block-icon">${def.icon}</span><span>${def.label}</span>`;
    el.addEventListener('dragstart', e => e.dataTransfer.setData('defId', def.id));
    el.addEventListener('dblclick', () => addBlockToCenter(def.id));
    container.appendChild(el);
  });
}

function switchSideTab(tab, el) {
  document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('blocksPanel').style.display = tab === 'blocks' ? '' : 'none';
  document.getElementById('searchPanel').style.display = tab === 'search' ? '' : 'none';
}

// ============================================================
// CANVAS DnD
// ============================================================
const canvasWrap = document.getElementById('canvasWrap');
const canvas = document.getElementById('canvas');

canvasWrap.addEventListener('dragover', e => { e.preventDefault(); });
canvasWrap.addEventListener('drop', e => {
  e.preventDefault();
  const defId = e.dataTransfer.getData('defId');
  if (!defId) return;
  const rect = canvasWrap.getBoundingClientRect();
  const x = (e.clientX - rect.left - panX) / zoom;
  const y = (e.clientY - rect.top - panY) / zoom;
  addBlock(defId, x, y);
});

// ============================================================
// ADD BLOCK
// ============================================================
function addBlockToCenter(defId) {
  const rect = canvasWrap.getBoundingClientRect();
  const x = (rect.width / 2 - panX) / zoom - 90 + Math.random() * 60 - 30;
  const y = (rect.height / 2 - panY) / zoom - 50 + Math.random() * 60 - 30;
  addBlock(defId, x, y);
}

function addBlock(defId, x, y) {
  const def = BLOCK_DEFS.find(b => b.id === defId);
  if (!def) return;

  const id = `block_${nextId++}`;
  const fields = {};
  def.fields.forEach(f => fields[f.name] = f.default);

  const el = document.createElement('div');
  el.className = 'block-node';
  el.id = id;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.style.borderTop = `3px solid ${def.color}`;

  // Header
  const header = document.createElement('div');
  header.className = 'block-header';
  header.style.background = hexAlpha(def.color, 0.25);
  header.innerHTML = `
    <span class="bh-icon">${def.icon}</span>
    <span class="bh-label">${def.label}</span>
    <button class="block-close" onclick="removeBlock('${id}')">‚úï</button>
  `;

  // Body with fields
  const body = document.createElement('div');
  body.className = 'block-body';

  def.fields.forEach(f => {
    const row = document.createElement('div');
    row.className = 'block-field';
    let inputEl;
    if (f.type === 'select') {
      inputEl = document.createElement('select');
      f.options.forEach(opt => {
        const o = document.createElement('option');
        o.value = opt; o.textContent = opt;
        if (opt === f.default) o.selected = true;
        inputEl.appendChild(o);
      });
    } else {
      inputEl = document.createElement('input');
      inputEl.type = 'text';
      inputEl.value = f.default;
      inputEl.placeholder = f.label;
    }
    inputEl.addEventListener('input', ev => {
      fields[f.name] = ev.target.value;
      updateCodePreview();
      updateVars();
    });
    inputEl.addEventListener('change', ev => { fields[f.name] = ev.target.value; updateCodePreview(); updateVars(); });
    row.innerHTML = `<label>${f.label}</label>`;
    row.appendChild(inputEl);
    body.appendChild(row);
  });

  // Connectors ‚Äî drag-wire OR click-to-connect
  const connTop = document.createElement('div');
  connTop.className = 'block-connector top';
  connTop.title = 'Drag or click to wire';
  const connBot = document.createElement('div');
  connBot.className = 'block-connector bottom';
  connBot.title = 'Drag or click to wire';

  const ports = [connTop, connBot];

  let connBody = null;
  if (def.hasBody) {
    connBody = document.createElement('div');
    connBody.className = 'block-connector body-port';
    connBody.title = 'Connect body (contents)';
    connBody.innerHTML = '<span class="body-port-label">{ }</span>';
    ports.push(connBody);
  }

  ports.forEach(port => {
    const portType = port === connTop ? 'top' : port === connBot ? 'bottom' : 'body';

    // Mouse
    port.addEventListener('mousedown', e => {
      e.stopPropagation(); e.preventDefault();
      startPortDrag(id, portType, e.clientX, e.clientY);
    });

    // Touch
    port.addEventListener('touchstart', e => {
      e.stopPropagation(); e.preventDefault();
      const t = e.touches[0];
      startPortDrag(id, portType, t.clientX, t.clientY);
    }, { passive: false });
  });

  el.appendChild(connTop);
  el.appendChild(header);
  el.appendChild(body);
  if (connBody) el.appendChild(connBody);
  el.appendChild(connBot);
  canvas.appendChild(el);

  // Dragging (mouse)
  header.addEventListener('mousedown', e => {
    if (e.target.classList.contains('block-close')) return;
    e.preventDefault();
    e.stopPropagation();
    draggingBlock = id;
    selectBlock(id);
    // dragOffset in canvas-local units: cursor position minus node top-left
    const rect = canvasWrap.getBoundingClientRect();
    dragOffset.x = (e.clientX - rect.left - panX) / zoom - node_ref.x;
    dragOffset.y = (e.clientY - rect.top  - panY) / zoom - node_ref.y;
    el.classList.add('dragging');
  });

  // Touch dragging
  header.addEventListener('touchstart', e => {
    if (e.target.classList.contains('block-close')) return;
    e.preventDefault();
    e.stopPropagation();
    const touch = e.touches[0];
    draggingBlock = id;
    selectBlock(id);
    const rect = canvasWrap.getBoundingClientRect();
    dragOffset.x = (touch.clientX - rect.left - panX) / zoom - node_ref.x;
    dragOffset.y = (touch.clientY - rect.top  - panY) / zoom - node_ref.y;
    el.classList.add('dragging');
  }, { passive: false });

  el.addEventListener('mousedown', e => { selectBlock(id); });

  const node_ref = { id, defId, x, y, fields, el, def };
  blockNodes.push(node_ref);

  updateHint();
  updateCodePreview();
  updateStatus();
  updateVars();
}

function removeBlock(id) {
  connections = connections.filter(c => c.from !== id && c.to !== id);
  const node = blockNodes.find(b => b.id === id);
  if (node) node.el.remove();
  blockNodes = blockNodes.filter(b => b.id !== id);
  if (selectedBlock === id) selectedBlock = null;
  updateHint();
  updateCodePreview();
  drawConnections();
  updateStatus();
  updateVars();
}

function selectBlock(id) {
  if (selectedBlock) {
    const prev = document.getElementById(selectedBlock);
    if (prev) prev.classList.remove('selected');
  }
  selectedBlock = id;
  const el = document.getElementById(id);
  if (el) el.classList.add('selected');
}

// ============================================================
// WIRE DRAG SYSTEM ‚Äî drag-wire with snap-to-nearest + click fallback
// ============================================================
const DRAG_THRESHOLD = 8; // px screen-space before entering drag mode

// Check if a target port is valid: different node, not already connected on that port
function isCompatiblePort(fromId, fromPort, toId, toPort) {
  if (fromId === toId) return false;
  const taken = connections.some(c =>
    (c.from === toId && c.fromPort === toPort) ||
    (c.to   === toId && c.toPort   === toPort)
  );
  return !taken;
}

// All valid target ports in canvas-local coords
function getAllPortPositions(fromId, fromPort) {
  const result = [];
  blockNodes.forEach(n => {
    ['top', 'bottom', ...(n.def.hasBody ? ['body'] : [])].forEach(pt => {
      if (!isCompatiblePort(fromId, fromPort, n.id, pt)) return;
      const p = getPortCenter(n.id, pt);
      if (p) result.push({ nodeId: n.id, portType: pt, cx: p.x, cy: p.y });
    });
  });
  return result;
}

// Find nearest valid port -- no distance limit, always snaps to something
function findSnapTarget(canvasX, canvasY, fromId, fromPort) {
  const candidates = getAllPortPositions(fromId, fromPort);
  let best = null, bestDist = Infinity;
  candidates.forEach(c => {
    const d = Math.hypot(c.cx - canvasX, c.cy - canvasY);
    if (d < bestDist) { bestDist = d; best = c; }
  });
  return best;
}

// wireDrag state object
let wireDrag = {
  active:    false,
  dragging:  false,
  fromId:    null,
  fromPort:  null,
  startX:    0, startY: 0,
  curX:      0, curY:   0,
  snapTarget: null,
};

function startPortDrag(nodeId, portType, screenX, screenY) {
  wireDrag = {
    active: true, dragging: false,
    fromId: nodeId, fromPort: portType,
    startX: screenX, startY: screenY,
    curX: screenX, curY: screenY,
    snapTarget: null,
  };
  // Highlight source port
  const node = blockNodes.find(b => b.id === nodeId);
  if (node) {
    node.el.querySelectorAll('.block-connector').forEach(p => {
      const pt = p.classList.contains('top') ? 'top' : p.classList.contains('bottom') ? 'bottom' : 'body';
      if (pt === portType) p.classList.add('port-selected');
    });
  }
  drawConnections();
}

function updatePortDrag(screenX, screenY) {
  if (!wireDrag.active) return;
  wireDrag.curX = screenX;
  wireDrag.curY = screenY;

  const dx = screenX - wireDrag.startX;
  const dy = screenY - wireDrag.startY;
  if (!wireDrag.dragging && Math.hypot(dx, dy) > DRAG_THRESHOLD) {
    wireDrag.dragging = true;
    canvasWrap.classList.add('wiring');
    showWireCancel();
  }

  if (wireDrag.dragging) {
    // Convert cursor to canvas-local
    const r = canvasWrap.getBoundingClientRect();
    const cx = (screenX - r.left - panX) / zoom;
    const cy = (screenY - r.top  - panY) / zoom;
    wireDrag.snapTarget = findSnapTarget(cx, cy, wireDrag.fromId, wireDrag.fromPort);
    // Highlight snap target
    document.querySelectorAll('.block-connector.snap-highlight')
      .forEach(p => p.classList.remove('snap-highlight'));
    if (wireDrag.snapTarget) {
      const tn = blockNodes.find(b => b.id === wireDrag.snapTarget.nodeId);
      if (tn) {
        tn.el.querySelectorAll('.block-connector').forEach(p => {
          const pt = p.classList.contains('top') ? 'top' : p.classList.contains('bottom') ? 'bottom' : 'body';
          if (pt === wireDrag.snapTarget.portType) p.classList.add('snap-highlight');
        });
      }
    }
    drawConnections();
  }
}

function commitPortDrag(screenX, screenY) {
  if (!wireDrag.active) return;
  const { fromId, fromPort, dragging, snapTarget } = wireDrag;

  // Clear highlights
  document.querySelectorAll('.block-connector.port-selected, .block-connector.snap-highlight')
    .forEach(p => { p.classList.remove('port-selected'); p.classList.remove('snap-highlight'); });
  canvasWrap.classList.remove('wiring');
  hideWireCancel();
  wireDrag = { active: false, dragging: false, fromId: null, fromPort: null, startX:0, startY:0, curX:0, curY:0, snapTarget: null };

  if (!dragging) {
    // Short release = click fallback (toggle)
    handlePortClick_commit(fromId, fromPort);
    drawConnections();
    return;
  }

  // Dragged ‚Äî connect to snap target if any
  if (snapTarget) {
    makeConnection(fromId, fromPort, snapTarget.nodeId, snapTarget.portType);
  } else {
    setStatus('No port nearby ‚Äî wire dropped');
  }
  drawConnections();
}

function cancelPortDrag() {
  document.querySelectorAll('.block-connector.port-selected, .block-connector.snap-highlight')
    .forEach(p => { p.classList.remove('port-selected'); p.classList.remove('snap-highlight'); });
  canvasWrap.classList.remove('wiring');
  hideWireCancel();
  wireDrag = { active: false, dragging: false, fromId: null, fromPort: null, startX:0, startY:0, curX:0, curY:0, snapTarget: null };
  drawConnections();
}

// Click fallback ‚Äî handles the two-click toggle behaviour
let pendingClick = null;  // { fromId, fromPort }

function handlePortClick_commit(nodeId, portType) {
  if (!pendingClick) {
    pendingClick = { fromId: nodeId, fromPort: portType };
    // Highlight
    const node = blockNodes.find(b => b.id === nodeId);
    if (node) {
      node.el.querySelectorAll('.block-connector').forEach(p => {
        const pt = p.classList.contains('top') ? 'top' : p.classList.contains('bottom') ? 'bottom' : 'body';
        if (pt === portType) p.classList.add('port-selected');
      });
    }
    canvasWrap.classList.add('wiring');
    showWireCancel();
  } else {
    const { fromId, fromPort } = pendingClick;
    pendingClick = null;
    canvasWrap.classList.remove('wiring');
    hideWireCancel();
    document.querySelectorAll('.block-connector.port-selected').forEach(p => p.classList.remove('port-selected'));
    if (fromId === nodeId) return; // same node ‚Äî cancel
    makeConnection(fromId, fromPort, nodeId, portType);
  }
}

function makeConnection(fromId, fromPort, toId, toPort) {
  // Toggle if exact same connection exists
  const existingIdx = connections.findIndex(c =>
    (c.from === fromId && c.fromPort === fromPort && c.to === toId   && c.toPort === toPort) ||
    (c.from === toId   && c.fromPort === toPort   && c.to === fromId && c.toPort === fromPort)
  );
  if (existingIdx !== -1) {
    connections.splice(existingIdx, 1);
    updateCodePreview();
    setStatus('Wire removed');
    return;
  }
  // Remove prior connections on the same ports
  connections = connections.filter(c =>
    !(c.from === fromId && c.fromPort === fromPort) &&
    !(c.to   === fromId && c.toPort   === fromPort)
  );
  connections.push({ from: fromId, fromPort, to: toId, toPort });
  updateCodePreview();
  setStatus('Connected!');
}

// Cancel button ‚Äî works for both drag-wire and click-pending states
function cancelWireConnect() {
  cancelPortDrag();
  pendingClick = null;
  document.querySelectorAll('.block-connector.port-selected').forEach(p => p.classList.remove('port-selected'));
  canvasWrap.classList.remove('wiring');
  hideWireCancel();
  drawConnections();
}

// Wire global mouse/touch handlers (attached to document so drag works outside canvas)
document.addEventListener('mousemove', e => {
  if (wireDrag.active) { updatePortDrag(e.clientX, e.clientY); return; }
  // ... rest handled in pan/drag section
}, { capture: false });

document.addEventListener('mouseup', e => {
  if (wireDrag.active) { commitPortDrag(e.clientX, e.clientY); return; }
}, { capture: false });

document.addEventListener('touchmove', e => {
  if (wireDrag.active) {
    e.preventDefault();
    updatePortDrag(e.touches[0].clientX, e.touches[0].clientY);
    return;
  }
}, { capture: false, passive: false });

document.addEventListener('touchend', e => {
  if (wireDrag.active) {
    const t = e.changedTouches[0];
    commitPortDrag(t.clientX, t.clientY);
    return;
  }
}, { capture: false });

function showWireCancel() {
  let btn = document.getElementById('wireCancelBtn');
  if (!btn) {
    btn = document.createElement('button');
    btn.id = 'wireCancelBtn';
    btn.className = 'wire-cancel-btn';
    btn.innerHTML = '‚úï Cancel Wire';
    btn.addEventListener('click', cancelWireConnect);
    btn.addEventListener('touchend', e => { e.preventDefault(); cancelWireConnect(); }, { passive: false });
    document.body.appendChild(btn);
  }
  btn.style.display = 'flex';
}

function hideWireCancel() {
  const btn = document.getElementById('wireCancelBtn');
  if (btn) btn.style.display = 'none';
}

// Legacy alias used by old cancel button etc.
function handlePortClick(nodeId, portType) {
  handlePortClick_commit(nodeId, portType);
  drawConnections();
}

function getPortCenter(nodeId, port) {
  const node = blockNodes.find(b => b.id === nodeId);
  if (!node) return null;
  const w = node.el.offsetWidth;
  const h = node.el.offsetHeight;
  if (port === 'top')    return { x: node.x + w / 2, y: node.y - 7 };
  if (port === 'bottom') return { x: node.x + w / 2, y: node.y + h + 7 };
  if (port === 'body')   return { x: node.x + w,     y: node.y + h / 2 };
  return null;
}

// Returns left/right edge coords for ribbon wire ‚Äî canvas-local
function getPortEdges(nodeId, port) {
  const node = blockNodes.find(b => b.id === nodeId);
  if (!node) return null;
  const w = node.el.offsetWidth;
  const h = node.el.offsetHeight;
  if (port === 'top')    return { lx: node.x,     rx: node.x + w, y: node.y - 7 };
  if (port === 'bottom') return { lx: node.x,     rx: node.x + w, y: node.y + h + 7 };
  if (port === 'body')   return { lx: node.x + w, rx: node.x + w, y: node.y + h / 2 };
  return null;
}

// ============================================================
// ZOOM / PAN / DRAG ‚Äî unified camera system
// coordinate model: screen = canvas * zoom + pan  (pan is wrapper-relative)
// ============================================================
function applyTransform() {
  canvas.style.transformOrigin = '0 0';
  canvas.style.transform = `translate(${panX}px,${panY}px) scale(${zoom})`;
}
function applyZoom() { applyTransform(); drawConnections(); }

// Zoom keeping canvas point under (wx, wy) [wrapper-relative] fixed
function zoomAtPoint(newZoom, wx, wy) {
  const clamped = Math.min(3, Math.max(0.15, newZoom));
  const cx = (wx - panX) / zoom;
  const cy = (wy - panY) / zoom;
  zoom = clamped;
  panX = wx - cx * zoom;
  panY = wy - cy * zoom;
  applyTransform();
  drawConnections();
}

function zoomIn()    { const r = canvasWrap.getBoundingClientRect(); zoomAtPoint(zoom * 1.18, r.width / 2, r.height / 2); }
function zoomOut()   { const r = canvasWrap.getBoundingClientRect(); zoomAtPoint(zoom / 1.18, r.width / 2, r.height / 2); }
function resetView() { zoom = 1; panX = 40; panY = 40; applyTransform(); drawConnections(); }

// Wheel zoom toward cursor
canvasWrap.addEventListener('wheel', e => {
  e.preventDefault();
  const r  = canvasWrap.getBoundingClientRect();
  const wx = e.clientX - r.left;
  const wy = e.clientY - r.top;
  zoomAtPoint(zoom * (e.deltaY < 0 ? 1.1 : 0.9), wx, wy);
}, { passive: false });

// ---- MOUSE: pan on background, drag blocks ----
let isPanning = false, panStart = { x: 0, y: 0 };

canvasWrap.addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  const bg = e.target === canvasWrap || e.target === canvas || e.target.id === 'svgLayer';
  if (!bg) return;
  if (wireDrag.active || pendingClick) { cancelWireConnect(); return; }
  e.preventDefault();
  isPanning  = true;
  panStart.x = e.clientX - panX;
  panStart.y = e.clientY - panY;
  canvasWrap.style.cursor = 'grabbing';
});

document.addEventListener('mousemove', e => {
  if (wireDrag.active) return;
  if (isPanning) {
    panX = e.clientX - panStart.x;
    panY = e.clientY - panStart.y;
    applyTransform();
    drawConnections();
    return;
  }
  if (!draggingBlock) return;
  const node = blockNodes.find(b => b.id === draggingBlock);
  if (!node) return;
  const r = canvasWrap.getBoundingClientRect();
  node.x = (e.clientX - r.left - panX) / zoom - dragOffset.x;
  node.y = (e.clientY - r.top  - panY) / zoom - dragOffset.y;
  node.el.style.left = node.x + 'px';
  node.el.style.top  = node.y + 'px';
  updateProximity(draggingBlock);
  drawConnections();
});

document.addEventListener('mouseup', () => {
  if (wireDrag.active) return;
  if (isPanning) { isPanning = false; canvasWrap.style.cursor = ''; }
  if (draggingBlock) {
    commitProximityConnect(draggingBlock);
    const n = blockNodes.find(b => b.id === draggingBlock);
    if (n) n.el.classList.remove('dragging');
    draggingBlock = null;
    qDraggingDefId = null;
  }
});

// ---- TOUCH: pan / pinch-zoom / block drag ----
let lastPinchDist = null;
let touchPanning  = false, touchPanStart = { x: 0, y: 0 };

canvasWrap.addEventListener('touchstart', e => {
  if (e.touches.length === 2) {
    lastPinchDist = null;
    touchPanning  = false;
    return;
  }
  if (e.touches.length === 1 && !draggingBlock) {
    const bg = e.target === canvasWrap || e.target === canvas || e.target.id === 'svgLayer';
    if (bg) {
      const t = e.touches[0];
      touchPanning    = true;
      touchPanStart.x = t.clientX - panX;
      touchPanStart.y = t.clientY - panY;
    }
  }
}, { passive: true });

document.addEventListener('touchmove', e => {
  if (wireDrag.active) return; // handled by wire drag listener
  if (e.touches.length === 2) {
    e.preventDefault();
    const t0 = e.touches[0], t1 = e.touches[1];
    const dist = Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
    if (lastPinchDist !== null) {
      const r   = canvasWrap.getBoundingClientRect();
      const wx  = (t0.clientX + t1.clientX) / 2 - r.left;
      const wy  = (t0.clientY + t1.clientY) / 2 - r.top;
      zoomAtPoint(zoom * dist / lastPinchDist, wx, wy);
    }
    lastPinchDist = dist;
    return;
  }
  if (draggingBlock) {
    e.preventDefault();
    const t = e.touches[0];
    const node = blockNodes.find(b => b.id === draggingBlock);
    if (!node) return;
    const r = canvasWrap.getBoundingClientRect();
    node.x = (t.clientX - r.left - panX) / zoom - dragOffset.x;
    node.y = (t.clientY - r.top  - panY) / zoom - dragOffset.y;
    node.el.style.left = node.x + 'px';
    node.el.style.top  = node.y + 'px';
    drawConnections();
    return;
  }
  if (touchPanning) {
    e.preventDefault();
    const t = e.touches[0];
    panX = t.clientX - touchPanStart.x;
    panY = t.clientY - touchPanStart.y;
    applyTransform();
    drawConnections();
  }
}, { passive: false });

document.addEventListener('touchend', e => {
  if (wireDrag.active) return; // handled by wire drag listener
  if (e.touches.length < 2) lastPinchDist = null;
  if (e.touches.length === 0) { touchPanning = false; }
  if (draggingBlock && e.touches.length === 0) {
    const n = blockNodes.find(b => b.id === draggingBlock);
    if (n) n.el.classList.remove('dragging');
    draggingBlock = null;
  }
});

function autoArrange() {
  const cols = Math.ceil(Math.sqrt(blockNodes.length));
  blockNodes.forEach((node, i) => {
    const col = i % cols;
    const row = Math.floor(i / cols);
    node.x = 40 + col * 220;
    node.y = 40 + row * 160;
    node.el.style.left = node.x + 'px';
    node.el.style.top = node.y + 'px';
  });
  drawConnections();
  setStatus('Auto-arranged!');
}

// Build a ribbon SVG path between two port edge sets
function ribbonPath(e1, e2) {
  // e1, e2: { lx, rx, y }
  const cy = (e1.y + e2.y) / 2;
  // Left edge bezier (top-left ‚Üí bottom-left)
  const left  = `M${e1.lx},${e1.y} C${e1.lx},${cy} ${e2.lx},${cy} ${e2.lx},${e2.y}`;
  // Right edge bezier reversed (bottom-right ‚Üí top-right) to close the shape
  const right = `L${e2.rx},${e2.y} C${e2.rx},${cy} ${e1.rx},${cy} ${e1.rx},${e1.y} Z`;
  return left + ' ' + right;
}

// ============================================================
// CONNECTIONS (SVG)
// ============================================================
function drawConnections() {
  const svg = document.getElementById('svgLayer');
  svg.innerHTML = '';

  // Define gradient for ribbons
  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  const grad = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
  grad.setAttribute('id', 'ribGrad');
  grad.setAttribute('gradientUnits', 'userSpaceOnUse');
  grad.setAttribute('x1', '0'); grad.setAttribute('y1', '0');
  grad.setAttribute('x2', '0'); grad.setAttribute('y2', '1');
  [['0%','rgba(124,92,252,0.55)'],['50%','rgba(0,229,255,0.35)'],['100%','rgba(124,92,252,0.55)']].forEach(([offset, color]) => {
    const stop = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop.setAttribute('offset', offset);
    stop.setAttribute('stop-color', color);
    grad.appendChild(stop);
  });
  defs.appendChild(grad);
  svg.appendChild(defs);

  connections.forEach(({ from, fromPort, to, toPort }, idx) => {
    const isBody = (fromPort === 'body' || toPort === 'body');
    const p1 = getPortCenter(from, fromPort || 'bottom');
    const p2 = getPortCenter(to,   toPort  || 'top');
    if (!p1 || !p2) return;

    let visPath, hitD;

    if (!isBody) {
      // Ribbon shape using edge coords
      const e1 = getPortEdges(from, fromPort || 'bottom');
      const e2 = getPortEdges(to,   toPort   || 'top');
      if (e1 && e2) {
        const shapePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        shapePath.setAttribute('d', ribbonPath(e1, e2));
        shapePath.setAttribute('fill', 'url(#ribGrad)');
        shapePath.setAttribute('stroke', 'rgba(0,229,255,0.25)');
        shapePath.setAttribute('stroke-width', '0.5');
        shapePath.style.pointerEvents = 'none';
        svg.appendChild(shapePath);
        hitD = `M${p1.x},${p1.y} C${p1.x},${(p1.y+p2.y)/2} ${p2.x},${(p1.y+p2.y)/2} ${p2.x},${p2.y}`;
      }
    } else {
      // Body port ‚Äî keep as a single bezier line (sideways)
      const cx = (p1.x + p2.x) / 2;
      hitD = `M${p1.x},${p1.y} C${cx},${p1.y} ${cx},${p2.y} ${p2.x},${p2.y}`;
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', hitD);
      path.setAttribute('class', 'conn-line body-line');
      path.style.pointerEvents = 'none';
      svg.appendChild(path);
    }

    if (hitD) {
      const hitPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      hitPath.setAttribute('d', hitD);
      hitPath.setAttribute('stroke', 'rgba(0,0,0,0)');
      hitPath.setAttribute('stroke-width', '18');
      hitPath.setAttribute('fill', 'none');
      hitPath.style.pointerEvents = 'stroke';
      hitPath.style.cursor = 'pointer';
      const capturedIdx = idx;
      hitPath.addEventListener('click', e => {
        e.stopPropagation();
        connections.splice(capturedIdx, 1);
        drawConnections(); updateCodePreview(); setStatus('Wire removed');
      });
      svg.appendChild(hitPath);
    }
  });

  // Live drag wire preview ‚Äî ribbon from port edges to cursor
  if (wireDrag.active && wireDrag.dragging) {
    const e1 = getPortEdges(wireDrag.fromId, wireDrag.fromPort);
    const p1 = getPortCenter(wireDrag.fromId, wireDrag.fromPort);
    if (p1) {
      let tx, ty, te;
      if (wireDrag.snapTarget) {
        const sp = getPortCenter(wireDrag.snapTarget.nodeId, wireDrag.snapTarget.portType);
        te = getPortEdges(wireDrag.snapTarget.nodeId, wireDrag.snapTarget.portType);
        if (sp) { tx = sp.x; ty = sp.y; }
      }
      if (tx === undefined) {
        const r = canvasWrap.getBoundingClientRect();
        tx = (wireDrag.curX - r.left - panX) / zoom;
        ty = (wireDrag.curY - r.top  - panY) / zoom;
      }

      const isBody = wireDrag.fromPort === 'body';
      const snapping = !!wireDrag.snapTarget;

      if (!isBody && e1 && te) {
        // Ribbon preview
        const shapePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        shapePath.setAttribute('d', ribbonPath(e1, te));
        shapePath.setAttribute('fill', snapping ? 'rgba(0,229,255,0.4)' : 'rgba(255,255,255,0.1)');
        shapePath.setAttribute('stroke', snapping ? 'rgba(0,229,255,0.6)' : 'rgba(255,255,255,0.2)');
        shapePath.setAttribute('stroke-width', '0.5');
        shapePath.style.pointerEvents = 'none';
        svg.appendChild(shapePath);
      } else if (!isBody && e1) {
        // Ribbon preview to cursor ‚Äî fake edge set
        const fakeEdge = { lx: tx - (e1.rx - e1.lx) / 2, rx: tx + (e1.rx - e1.lx) / 2, y: ty };
        const shapePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        shapePath.setAttribute('d', ribbonPath(e1, fakeEdge));
        shapePath.setAttribute('fill', 'rgba(255,255,255,0.08)');
        shapePath.setAttribute('stroke', 'rgba(255,255,255,0.15)');
        shapePath.setAttribute('stroke-width', '0.5');
        shapePath.style.pointerEvents = 'none';
        svg.appendChild(shapePath);
      } else {
        // Body port ‚Äî single line
        const cx = (p1.x + tx) / 2;
        const previewLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        previewLine.setAttribute('d', `M${p1.x},${p1.y} C${cx},${p1.y} ${cx},${ty} ${tx},${ty}`);
        previewLine.setAttribute('stroke', snapping ? 'var(--accent2)' : 'var(--text-dim)');
        previewLine.setAttribute('stroke-width', snapping ? '2' : '1.5');
        previewLine.setAttribute('fill', 'none');
        previewLine.setAttribute('stroke-dasharray', '6 3');
        previewLine.setAttribute('opacity', snapping ? '1' : '0.4');
        previewLine.style.pointerEvents = 'none';
        svg.appendChild(previewLine);
      }
    }
  } else if (pendingClick) {
    // Click-mode pending stub
    const origin = getPortCenter(pendingClick.fromId, pendingClick.fromPort);
    if (origin) {
      const isBody = pendingClick.fromPort === 'body';
      const stubLen = 28;
      const x2 = isBody ? origin.x + stubLen : origin.x;
      const y2 = isBody ? origin.y : origin.y + (pendingClick.fromPort === 'top' ? -stubLen : stubLen);
      const stub = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      stub.setAttribute('x1', origin.x); stub.setAttribute('y1', origin.y);
      stub.setAttribute('x2', x2);       stub.setAttribute('y2', y2);
      stub.setAttribute('stroke', 'var(--accent2)');
      stub.setAttribute('stroke-width', '2');
      stub.setAttribute('stroke-dasharray', '4 3');
      stub.setAttribute('opacity', '0.85');
      stub.style.pointerEvents = 'none';
      svg.appendChild(stub);
    }
  }

  // Proximity auto-connect ghost while dragging a block
  if (draggingBlock && proximityTarget) {
    const fromEdge = getPortEdges(draggingBlock, proximityTarget.fromPort);
    const toEdge   = getPortEdges(proximityTarget.nodeId, proximityTarget.toPort);
    if (fromEdge && toEdge) {
      const ghost = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      ghost.setAttribute('d', ribbonPath(fromEdge, toEdge));
      ghost.setAttribute('fill', 'rgba(0,229,255,0.25)');
      ghost.setAttribute('stroke', 'rgba(0,229,255,0.5)');
      ghost.setAttribute('stroke-width', '0.5');
      ghost.setAttribute('stroke-dasharray', '6 3');
      ghost.style.pointerEvents = 'none';
      svg.appendChild(ghost);
    }
  }
}

// ============================================================
// CODE GENERATION
// ============================================================
function generateCode() {
  if (blockNodes.length === 0) return '# Add some blocks to generate code!';

  // Build a set of nodes that are "body children" of a container
  // body connection: { from: containerId, fromPort: 'body', to: childId, toPort: ... }
  const bodyChildOf = {}; // childId -> parentId
  connections.forEach(c => {
    if (c.fromPort === 'body') bodyChildOf[c.to] = c.from;
    if (c.toPort === 'body')   bodyChildOf[c.from] = c.to;
  });

  // Recursively emit lines for a node and its body children
  function emitNode(node, indent) {
    const prefix = '    '.repeat(indent);
    const code = node.def.code(node.fields);
    const lines = code.split('\n').map(l => prefix + l);
    // Find all body children of this node, sorted by Y
    const children = blockNodes
      .filter(n => bodyChildOf[n.id] === node.id)
      .sort((a, b) => a.y - b.y);
    if (node.def.hasBody) {
      if (children.length === 0) {
        lines.push(prefix + '    pass');
      } else {
        children.forEach(child => lines.push(...emitNode(child, indent + 1)));
      }
    }
    return lines;
  }

  // Top-level nodes: not a body-child of anything, sorted by Y
  const topLevel = blockNodes
    .filter(n => !bodyChildOf[n.id])
    .sort((a, b) => a.y - b.y);

  const allLines = [];
  topLevel.forEach(node => allLines.push(...emitNode(node, 0)));
  return allLines.join('\n');
}

function syntaxHighlight(code) {
  const keywords = ['def', 'return', 'if', 'elif', 'else', 'for', 'while', 'in', 'not', 'and', 'or', 'import', 'from', 'as', 'try', 'except', 'finally', 'with', 'pass', 'break', 'continue', 'class', 'lambda', 'del', 'is', 'True', 'False', 'None', 'raise', 'yield', 'global', 'nonlocal'];
  const builtins = ['print', 'input', 'range', 'len', 'int', 'str', 'float', 'bool', 'list', 'dict', 'tuple', 'set', 'type', 'isinstance', 'hasattr', 'getattr', 'setattr', 'open', 'enumerate', 'zip', 'map', 'filter', 'sorted', 'reversed', 'min', 'max', 'sum', 'abs', 'round'];

  let result = '';
  const lines = code.split('\n');
  lines.forEach((line, li) => {
    if (li > 0) result += '\n';
    // Comment
    const commentIdx = line.indexOf('#');
    if (commentIdx !== -1) {
      result += processLine(line.slice(0, commentIdx), keywords, builtins);
      result += `<span class="cm">${escHtml(line.slice(commentIdx))}</span>`;
      return;
    }
    result += processLine(line, keywords, builtins);
  });
  return result;
}

function processLine(line, keywords, builtins) {
  let result = '';
  const tokens = line.split(/(\s+|[()[\]{},.:+\-*/%=<>!&|^~]+|"[^"]*"|'[^']*'|\b\w+\b)/);
  tokens.forEach(token => {
    if (!token) return;
    if (/^["'].*["']$/.test(token)) {
      result += `<span class="st">${escHtml(token)}</span>`;
    } else if (keywords.includes(token)) {
      result += `<span class="kw">${token}</span>`;
    } else if (builtins.includes(token)) {
      result += `<span class="bltn">${token}</span>`;
    } else if (/^\d+(\.\d+)?$/.test(token)) {
      result += `<span class="nm">${token}</span>`;
    } else if (/^[+\-*/%=<>!&|^~()[\]{},.:]+$/.test(token)) {
      result += `<span class="op">${escHtml(token)}</span>`;
    } else {
      result += escHtml(token);
    }
  });
  return result;
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function updateCodePreview() {
  const code = generateCode();
  const ta = document.getElementById('codeTextarea');
  const hl = document.getElementById('codeHighlight');
  if (ta && !ta._userEditing) ta.value = code;
  if (hl) hl.innerHTML = syntaxHighlight(code) + '\n'; // trailing \n keeps last-line height
  const lines = code.split('\n').length;
  const statsEl = document.getElementById('codeStats');
  if (statsEl) statsEl.textContent = `${lines} lines ¬∑ ${code.length} chars`;
  const lcEl = document.getElementById('lineCount');
  if (lcEl) lcEl.textContent = lines;
  // sync mobile pre
  const mcp = document.getElementById('mobileCodePreview');
  if (mcp) mcp.innerHTML = syntaxHighlight(code);
  const mcs = document.getElementById('mobileCodeStats');
  if (mcs) mcs.textContent = `${lines} lines ¬∑ ${code.length} chars`;
}

// Wire up textarea: sync scroll to highlight layer, live-highlight on input
function initCodeEditor() {
  const ta = document.getElementById('codeTextarea');
  const hl = document.getElementById('codeHighlight');
  if (!ta || !hl) return;

  // Scroll sync
  ta.addEventListener('scroll', () => {
    hl.scrollTop  = ta.scrollTop;
    hl.scrollLeft = ta.scrollLeft;
  });

  // Live highlight while typing (but don't regenerate canvas)
  ta.addEventListener('input', () => {
    ta._userEditing = true;
    hl.innerHTML = syntaxHighlight(ta.value) + '\n';
    const lines = ta.value.split('\n').length;
    const statsEl = document.getElementById('codeStats');
    if (statsEl) statsEl.textContent = `${lines} lines ¬∑ ${ta.value.length} chars`;
  });

  // Tab key inserts 4 spaces
  ta.addEventListener('keydown', e => {
    if (e.key === 'Tab') {
      e.preventDefault();
      const start = ta.selectionStart;
      const end   = ta.selectionEnd;
      ta.value = ta.value.slice(0, start) + '    ' + ta.value.slice(end);
      ta.selectionStart = ta.selectionEnd = start + 4;
      ta.dispatchEvent(new Event('input'));
    }
    // Ctrl/Cmd+Enter = parse to canvas
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      parseCodeToCanvas();
    }
  });
}

// ============================================================
// VARIABLE INSPECTOR
// ============================================================
function updateVars() {
  const area = document.getElementById('varsArea');
  const vars = {};
  blockNodes.forEach(node => {
    if (node.defId === 'assign' || node.defId === 'augassign') {
      const name = node.fields.name;
      const val = node.fields.value;
      if (name) vars[name] = { val, type: inferType(val) };
    }
    if (node.defId === 'listcreate') vars[node.fields.name] = { val: `[${node.fields.items}]`, type: 'list' };
    if (node.defId === 'dictcreate') vars[node.fields.name] = { val: `{...}`, type: 'dict' };
    if (node.defId === 'listcomp') vars[node.fields.result] = { val: '[...]', type: 'list' };
    if (node.defId === 'fstring' || node.defId === 'strformat') vars[node.fields.var] = { val: `"..."`, type: 'str' };
    if (node.defId === 'random') vars[node.fields.var] = { val: `random(${node.fields.lo}..${node.fields.hi})`, type: 'int' };
    if (node.defId === 'input') vars[node.fields.var] = { val: 'user input', type: 'str' };
    if (node.defId === 'call') vars[node.fields.result] = { val: `${node.fields.name}(...)`, type: 'any' };
    if (node.defId === 'lambda') vars[node.fields.var] = { val: `lambda ${node.fields.args}: ...`, type: 'function' };
  });

  if (Object.keys(vars).length === 0) {
    area.innerHTML = '<div class="vars-empty">No variables defined yet</div>';
    if (document.getElementById('mobileVarsArea')) document.getElementById('mobileVarsArea').innerHTML = area.innerHTML;
    return;
  }
  area.innerHTML = Object.entries(vars).map(([k, v]) =>
    `<div class="var-row">
      <span class="var-name">${k}</span>
      <span class="var-val" title="${v.val}">${v.val}</span>
      <span class="var-type">${v.type}</span>
    </div>`
  ).join('');
  if (document.getElementById('mobileVarsArea')) document.getElementById('mobileVarsArea').innerHTML = area.innerHTML;
}

function inferType(val) {
  if (!isNaN(Number(val))) return Number.isInteger(Number(val)) ? 'int' : 'float';
  if (val.startsWith('"') || val.startsWith("'")) return 'str';
  if (val === 'True' || val === 'False') return 'bool';
  if (val === 'None') return 'NoneType';
  if (val.startsWith('[')) return 'list';
  if (val.startsWith('{')) return 'dict';
  return 'any';
}

// ============================================================
// RUN CODE (Simulated Python Interpreter)
// ============================================================
function runCode() {
  if (isMobile()) {
    openMobilePanel('output');
    document.querySelectorAll('.mobile-nav-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('navOutput').classList.add('active');
  } else {
    const tabEl = document.querySelector('.panel-tab:nth-child(2)');
    if (tabEl) switchTab('output', tabEl);
  }
  const code = generateCode();
  const output = document.getElementById('outputArea');
  const mobileOutput = document.getElementById('mobileOutputArea');
  const addLine = (text, cls) => {
    [output, mobileOutput].forEach(o => {
      if (!o) return;
      const div = document.createElement('div');
      div.className = `output-line ${cls}`;
      div.textContent = text;
      o.appendChild(div);
    });
  };
  output.innerHTML = '<div class="output-line info">&#x26A1; Running program...</div>';
  if (mobileOutput) mobileOutput.innerHTML = '<div class="output-line info">&#x26A1; Running program...</div>';

  setTimeout(() => {
    try {
      const lines = code.split('\n');
      const results = simulateExecution(lines);
      results.forEach(r => addLine(r.text, r.type));
      addLine(`\n&#x2705; Program finished (${results.filter(r=>r.type==='out').length} outputs)`, 'info');
      setStatus('Run complete');
    } catch (e) {
      addLine(`RuntimeError: ${e.message}`, 'err');
    }
  }, 100);
}

function simulateExecution(lines) {
  const results = [];
  const env = {};
  import_math_available = false;
  import_random_available = false;

  lines.forEach(line => {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) {
      if (trimmed.startsWith('#')) results.push({ type: 'info', text: trimmed });
      return;
    }

    // Import
    if (trimmed.startsWith('import math')) { import_math_available = true; return; }
    if (trimmed.startsWith('import random')) { import_random_available = true; return; }
    if (trimmed.startsWith('import ')) { results.push({ type: 'info', text: `üì¶ ${trimmed}` }); return; }

    // Print
    const printMatch = trimmed.match(/^print\((.+)\)$/);
    if (printMatch) {
      const val = evalExpr(printMatch[1], env);
      results.push({ type: 'out', text: String(val) });
      return;
    }

    // Assignment: var = val
    const assignMatch = trimmed.match(/^(\w+)\s*=\s*(.+)$/);
    if (assignMatch && !trimmed.includes('==') && !trimmed.includes('!=') && !trimmed.includes('<=') && !trimmed.includes('>=')) {
      try {
        const val = evalExpr(assignMatch[2], env);
        env[assignMatch[1]] = val;
        results.push({ type: 'info', text: `‚Üí ${assignMatch[1]} = ${JSON.stringify(val)}` });
      } catch(e) {}
      return;
    }

    // Aug assign
    const augMatch = trimmed.match(/^(\w+)\s*(\+=|-=|\*=|\/=|\/\/=|%=|\*\*=)\s*(.+)$/);
    if (augMatch) {
      try {
        const curr = env[augMatch[1]] || 0;
        const rhs = evalExpr(augMatch[3], env);
        let newVal;
        switch(augMatch[2]) {
          case '+=': newVal = curr + rhs; break;
          case '-=': newVal = curr - rhs; break;
          case '*=': newVal = curr * rhs; break;
          case '/=': newVal = curr / rhs; break;
          case '//=': newVal = Math.floor(curr / rhs); break;
          case '%=': newVal = curr % rhs; break;
          case '**=': newVal = Math.pow(curr, rhs); break;
        }
        env[augMatch[1]] = newVal;
        results.push({ type: 'info', text: `‚Üí ${augMatch[1]} = ${newVal}` });
      } catch(e) {}
      return;
    }

    // For loop - simplified
    const forMatch = trimmed.match(/^for\s+(\w+)\s+in\s+(.+):$/);
    if (forMatch) {
      results.push({ type: 'info', text: `üîÅ for ${forMatch[1]} in ${forMatch[2]}` });
      return;
    }

    // Def function
    const defMatch = trimmed.match(/^def\s+(\w+)\((.*)\):$/);
    if (defMatch) {
      results.push({ type: 'info', text: `üß© Defined function: ${defMatch[1]}(${defMatch[2]})` });
      return;
    }

    // If statement
    if (trimmed.startsWith('if ') || trimmed.startsWith('elif ') || trimmed.startsWith('else:')) {
      results.push({ type: 'info', text: `üîÄ ${trimmed}` });
      return;
    }

    // Random
    const randMatch = trimmed.match(/^(\w+)\s*=\s*random\.randint\((\d+),\s*(\d+)\)$/);
    if (randMatch) {
      const lo = parseInt(randMatch[2]), hi = parseInt(randMatch[3]);
      const val = Math.floor(Math.random() * (hi - lo + 1)) + lo;
      env[randMatch[1]] = val;
      results.push({ type: 'info', text: `üé≤ ${randMatch[1]} = ${val}` });
      return;
    }

    results.push({ type: 'info', text: `  ${trimmed}` });
  });

  return results;
}

let import_math_available = false;
let import_random_available = false;

function evalExpr(expr, env) {
  expr = expr.trim();
  // String literals
  if ((expr.startsWith('"') && expr.endsWith('"')) || (expr.startsWith("'") && expr.endsWith("'"))) {
    return expr.slice(1, -1);
  }
  // F-string
  if (expr.startsWith('f"') || expr.startsWith("f'")) {
    let s = expr.slice(2, -1);
    s = s.replace(/\{(\w+)\}/g, (_, k) => env[k] !== undefined ? env[k] : k);
    return s;
  }
  // Number
  if (!isNaN(Number(expr))) return Number(expr);
  // Bool / None
  if (expr === 'True') return true;
  if (expr === 'False') return false;
  if (expr === 'None') return null;
  // List
  if (expr.startsWith('[') && expr.endsWith(']')) {
    try { return JSON.parse(expr); } catch { return expr; }
  }
  // Variable lookup
  if (/^\w+$/.test(expr) && env[expr] !== undefined) return env[expr];
  // Math
  try {
    const safeExpr = expr.replace(/\*\*/g, '**').replace(/math\./g, 'Math.');
    return Function(`"use strict"; const e=${JSON.stringify(env)}; with(e){ return (${safeExpr}); }`)();
  } catch { return expr; }
}

// ============================================================
// UTILITY
// ============================================================
function hexAlpha(hex, a) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  return `rgba(${r},${g},${b},${a})`;
}

function updateHint() {
  document.getElementById('canvasHint').style.opacity = blockNodes.length === 0 ? '1' : '0';
}

function updateStatus() {
  document.getElementById('blockCount').textContent = blockNodes.length;
}

function setStatus(msg) {
  document.getElementById('statusMsg').textContent = msg;
  setTimeout(() => document.getElementById('statusMsg').textContent = 'Ready', 3000);
}

function switchTab(name, el) {
  document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.panel-content').forEach(c => c.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('tab-' + name).classList.add('active');
}

function clearCanvas() {
  if (blockNodes.length === 0) return;
  if (!confirm('Clear all blocks?')) return;
  blockNodes.forEach(n => n.el.remove());
  blockNodes = [];
  connections = [];
  selectedBlock = null;
  document.getElementById('svgLayer').innerHTML = '';
  updateHint();
  updateCodePreview();
  updateStatus();
  updateVars();
  setStatus('Canvas cleared');
}

function clearOutput() {
  document.getElementById('outputArea').innerHTML = '<div class="output-line info">// Console cleared</div>';
}

function copyCode() {
  const ta = document.getElementById('codeTextarea');
  const text = ta ? ta.value : generateCode();
  navigator.clipboard.writeText(text).then(() => setStatus('Code copied!'));
}

function exportCode() {
  const code = generateCode();
  const blob = new Blob([code], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = document.getElementById('projectName').value || 'program.py';
  a.click();
  setStatus('Exported!');
}

// ============================================================
// EXAMPLES
// ============================================================
function loadExample() {
  const examples = [
    {
      name: 'Hello World',
      blocks: [
        { defId: 'comment', x: 80, y: 40, fields: { text: 'Simple Hello World program' } },
        { defId: 'assign', x: 80, y: 100, fields: { name: 'name', value: '"World"' } },
        { defId: 'fstring', x: 80, y: 160, fields: { var: 'msg', tmpl: 'Hello, {name}!' } },
        { defId: 'print', x: 80, y: 220, fields: { value: 'msg' } },
      ]
    },
    {
      name: 'Counter Loop',
      blocks: [
        { defId: 'assign', x: 80, y: 40, fields: { name: 'total', value: '0' } },
        { defId: 'for', x: 80, y: 100, fields: { var: 'i', iter: 'range(5)' } },
        { defId: 'augassign', x: 120, y: 160, fields: { name: 'total', op: '+=', value: 'i' } },
        { defId: 'print', x: 120, y: 220, fields: { value: 'f"i={i}, total={total}"' } },
        { defId: 'print', x: 80, y: 280, fields: { value: 'f"Final total: {total}"' } },
      ]
    },
    {
      name: 'Function + Math',
      blocks: [
        { defId: 'importmath', x: 80, y: 20, fields: {} },
        { defId: 'defn', x: 80, y: 80, fields: { name: 'circle_area', args: 'r' } },
        { defId: 'return', x: 120, y: 140, fields: { value: 'math.pi * r ** 2' } },
        { defId: 'call', x: 80, y: 210, fields: { result: 'area', name: 'circle_area', args: '5' } },
        { defId: 'print', x: 80, y: 270, fields: { value: 'f"Area: {area:.2f}"' } },
      ]
    }
  ];

  const choice = prompt(`Choose example (type number):\n${examples.map((e,i) => `${i+1}. ${e.name}`).join('\n')}`);
  const idx = parseInt(choice) - 1;
  if (isNaN(idx) || !examples[idx]) return;

  clearCanvas();
  const ex = examples[idx];
  document.getElementById('projectName').value = ex.name.toLowerCase().replace(/ /g,'_') + '.py';
  setTimeout(() => {
    ex.blocks.forEach(b => {
      addBlock(b.defId, b.x, b.y);
      const node = blockNodes[blockNodes.length - 1];
      Object.assign(node.fields, b.fields);
      const inputs = node.el.querySelectorAll('input, select');
      const defFields = node.def.fields;
      inputs.forEach((inp, i) => { if (defFields[i]) inp.value = node.fields[defFields[i].name]; });
      updateCodePreview();
      updateVars();
    });
    setStatus(`Loaded: ${ex.name}`);
  }, 50);
}

// ============================================================
// MOBILE NAVIGATION & PANELS
// ============================================================
let currentMobilePanel = null;

function isMobile() {
  return window.innerWidth <= 768;
}

function mobileNav(tab) {
  const navBtn = document.getElementById('nav' + tab.charAt(0).toUpperCase() + tab.slice(1));

  // Toggle: if already open, close it
  if (currentMobilePanel === tab) {
    closeAllMobile();
    document.querySelectorAll('.mobile-nav-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('navCanvas').classList.add('active');
    return;
  }

  document.querySelectorAll('.mobile-nav-btn').forEach(b => b.classList.remove('active'));
  if (navBtn) navBtn.classList.add('active');

  closeAllMobile();

  if (tab === 'blocks') {
    openMobileDrawer();
  } else if (tab === 'code') {
    openMobilePanel('code');
  } else if (tab === 'output') {
    openMobilePanel('output');
  } else if (tab === 'more') {
    openMobileMore();
    document.getElementById('navCanvas').classList.add('active');
    if (navBtn) navBtn.classList.remove('active');
  } else if (tab === 'canvas') {
    document.getElementById('navCanvas').classList.add('active');
  }
}

function openMobileMore() {
  document.getElementById('mobileMoreDrawer').classList.add('open');
  document.getElementById('backdrop').style.display = 'block';
}

function closeMobileMore() {
  document.getElementById('mobileMoreDrawer').classList.remove('open');
  document.getElementById('backdrop').style.display = 'none';
  document.querySelectorAll('.mobile-nav-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('navCanvas').classList.add('active');
}

function openMobilePanel(type) {
  const overlay = document.getElementById('mobilePanelOverlay');
  const titleEl = document.getElementById('mobilePanelTitle');
  ['code','output','vars'].forEach(t => {
    const el = document.getElementById('mobile-tab-' + t);
    if (el) el.style.display = 'none';
  });
  const target = document.getElementById('mobile-tab-' + type);
  if (target) target.style.display = 'flex';
  const titles = { code: 'Python Code', output: 'Output Console', vars: 'Variables' };
  titleEl.textContent = titles[type] || type;
  overlay.classList.add('open');
  currentMobilePanel = type;
  if (type === 'code') {
    const code = generateCode();
    document.getElementById('mobileCodePreview').innerHTML = syntaxHighlight(code);
    const lines = code.split('\n').length;
    document.getElementById('mobileCodeStats').textContent = `${lines} lines ¬∑ ${code.length} chars`;
  }
  if (type === 'vars') {
    document.getElementById('mobileVarsArea').innerHTML = document.getElementById('varsArea').innerHTML;
  }
}

function closeMobilePanel() {
  document.getElementById('mobilePanelOverlay').classList.remove('open');
  currentMobilePanel = null;
  document.querySelectorAll('.mobile-nav-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('navCanvas').classList.add('active');
}

function closeAllMobile() {
  document.getElementById('mobileDrawer').classList.remove('open');
  document.getElementById('mobileMoreDrawer').classList.remove('open');
  document.getElementById('mobilePanelOverlay').classList.remove('open');
  document.getElementById('backdrop').style.display = 'none';
  currentMobilePanel = null;
}

function openMobileDrawer() {
  document.getElementById('mobileDrawer').classList.add('open');
  document.getElementById('backdrop').style.display = 'block';
  buildDrawerBlocks();
  currentMobilePanel = 'blocks';
}

function buildDrawerBlocks() {
  const container = document.getElementById('drawerBlocks');
  container.innerHTML = '';
  document.getElementById('drawerSearch').value = '';
  const cats = [...new Set(BLOCK_DEFS.map(b => b.cat))];
  cats.forEach(cat => {
    const meta = CAT_META[cat];
    const catHeader = document.createElement('div');
    catHeader.className = 'cat-header';
    catHeader.textContent = meta.label;
    catHeader.style.color = meta.color;
    container.appendChild(catHeader);
    BLOCK_DEFS.filter(b => b.cat === cat).forEach(def => {
      container.appendChild(createDrawerBlock(def));
    });
  });
}

function createDrawerBlock(def) {
  const el = document.createElement('div');
  el.className = 'palette-block';
  el.style.borderLeftColor = def.color;
  el.innerHTML = `<span class="block-icon">${def.icon}</span><span>${def.label}</span>`;
  el.addEventListener('click', () => {
    addBlockToCenter(def.id);
    closeAllMobile();
    document.querySelectorAll('.mobile-nav-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('navCanvas').classList.add('active');
    setStatus(`Added: ${def.label}`);
  });
  return el;
}

function filterDrawerBlocks(query) {
  const container = document.getElementById('drawerBlocks');
  container.innerHTML = '';
  const q = query.toLowerCase().trim();
  if (!q) { buildDrawerBlocks(); return; }
  const results = BLOCK_DEFS.filter(b => b.label.toLowerCase().includes(q) || b.cat.includes(q));
  if (results.length === 0) {
    container.innerHTML = '<div class="vars-empty">No blocks found</div>';
    return;
  }
  results.forEach(def => container.appendChild(createDrawerBlock(def)));
}

function clearMobileOutput() {
  document.getElementById('mobileOutputArea').innerHTML = '<div class="output-line info">// Console cleared</div>';
}

// ============================================================
// PROMPT UTILS
// ============================================================
let promptResolve = null;
function showPrompt(title) {
  document.getElementById('promptTitle').textContent = title;
  document.getElementById('promptInput').value = '';
  document.getElementById('floatingPrompt').style.display = '';
  document.getElementById('backdrop').style.display = '';
  document.getElementById('promptInput').focus();
  return new Promise(r => promptResolve = r);
}
function confirmPrompt() {
  const val = document.getElementById('promptInput').value;
  closePrompt();
  if (promptResolve) promptResolve(val);
}
function closePrompt() {
  document.getElementById('floatingPrompt').style.display = 'none';
  document.getElementById('backdrop').style.display = 'none';
}
document.getElementById('promptInput').addEventListener('keydown', e => { if (e.key === 'Enter') confirmPrompt(); });

// ============================================================
// PYTHON PARSER ‚Üí CANVAS
// ============================================================

// Parse indentation level (4 spaces or 1 tab = 1 level)
function getIndent(line) {
  let n = 0;
  for (const ch of line) {
    if (ch === ' ') n++;
    else if (ch === '\t') n += 4;
    else break;
  }
  return Math.floor(n / 4);
}

// Try to match a raw line to a known block def. Returns { defId, fields } or null.
function matchLineToBlock(raw) {
  const t = raw.trim();
  if (!t || t === '') return null;

  // Comment
  if (t.startsWith('#')) return { defId: 'comment', fields: { text: t.slice(1).trim() } };

  // import math / import random / import X as Y / import X
  if (/^import\s+math\s*$/.test(t)) return { defId: 'importmath', fields: {} };
  if (/^import\s+random\s*$/.test(t)) return { defId: 'importrandom', fields: {} };
  let m;
  m = t.match(/^import\s+(\w+)(?:\s+as\s+(\w+))?\s*$/);
  if (m) return { defId: 'import', fields: { module: m[1], alias: m[2] || '' } };

  // for X in Y:
  m = t.match(/^for\s+(\w+)\s+in\s+(.+?)\s*:\s*$/);
  if (m) return { defId: 'for', fields: { var: m[1], iter: m[2] } };

  // while COND:
  m = t.match(/^while\s+(.+?)\s*:\s*$/);
  if (m) return { defId: 'while', fields: { condition: m[1] } };

  // if COND: / elif COND: / else:
  m = t.match(/^(?:if|elif)\s+(.+?)\s*:\s*$/);
  if (m) return { defId: 'if', fields: { condition: m[1] } };
  if (/^else\s*:\s*$/.test(t)) return { defId: 'if', fields: { condition: 'else' } };

  // def NAME(ARGS):
  m = t.match(/^def\s+(\w+)\s*\(([^)]*)\)\s*:\s*$/);
  if (m) return { defId: 'defn', fields: { name: m[1], args: m[2] } };

  // return VALUE
  m = t.match(/^return\s+(.*)/);
  if (m) return { defId: 'return', fields: { value: m[1].trim() } };

  // try: / except X:
  if (/^try\s*:\s*$/.test(t)) return { defId: 'tryexcept', fields: { exc: 'Exception as e' } };
  m = t.match(/^except\s+(.+?)\s*:\s*$/);
  if (m) return { defId: 'tryexcept', fields: { exc: m[1] } };

  // with open(FILE, MODE) as VAR:
  m = t.match(/^with\s+open\s*\((.+?),\s*(.+?)\)\s+as\s+(\w+)\s*:\s*$/);
  if (m) return { defId: 'withopen', fields: { file: m[1].trim(), mode: m[2].trim(), var: m[3] } };

  // print(VALUE)
  m = t.match(/^print\s*\((.+)\)\s*$/);
  if (m) return { defId: 'print', fields: { value: m[1] } };

  // VAR = input(PROMPT)
  m = t.match(/^(\w+)\s*=\s*input\s*\(([^)]*)\)\s*$/);
  if (m) return { defId: 'input', fields: { var: m[1], prompt: m[2] || '""' } };

  // VAR = random.randint(LO, HI)
  m = t.match(/^(\w+)\s*=\s*random\.randint\s*\((.+?),\s*(.+?)\)\s*$/);
  if (m) return { defId: 'random', fields: { var: m[1], lo: m[2].trim(), hi: m[3].trim() } };

  // VAR = f"TMPL" or VAR = f'TMPL'
  m = t.match(/^(\w+)\s*=\s*f["'](.*)["']\s*$/);
  if (m) return { defId: 'fstring', fields: { var: m[1], tmpl: m[2] } };

  // RESULT = TMPL.format(ARGS)
  m = t.match(/^(\w+)\s*=\s*(.+?)\.format\s*\((.+)\)\s*$/);
  if (m) return { defId: 'strformat', fields: { result: m[1], tmpl: m[2], args: m[3] } };

  // RESULT = STR.split(SEP)
  m = t.match(/^(\w+)\s*=\s*(\w+)\.split\s*\((.+)\)\s*$/);
  if (m) return { defId: 'strsplit', fields: { result: m[1], string: m[2], sep: m[3] } };

  // RESULT = SEP.join(LIST)
  m = t.match(/^(\w+)\s*=\s*(.+?)\.join\s*\((.+)\)\s*$/);
  if (m) return { defId: 'strjoin', fields: { result: m[1], sep: m[2], iter: m[3] } };

  // RESULT = [EXPR for VAR in ITER]
  m = t.match(/^(\w+)\s*=\s*\[\s*(.+?)\s+for\s+(\w+)\s+in\s+(.+?)\s*\]\s*$/);
  if (m) return { defId: 'listcomp', fields: { result: m[1], expr: m[2], var: m[3], iter: m[4] } };

  // VAR = [ITEMS]
  m = t.match(/^(\w+)\s*=\s*\[([^\]]*)\]\s*$/);
  if (m) return { defId: 'listcreate', fields: { name: m[1], items: m[2].trim() } };

  // VAR = {ITEMS}
  m = t.match(/^(\w+)\s*=\s*\{([^}]*)\}\s*$/);
  if (m) return { defId: 'dictcreate', fields: { name: m[1], items: m[2].trim() } };

  // VAR.append(ITEM)
  m = t.match(/^(\w+)\.append\s*\((.+)\)\s*$/);
  if (m) return { defId: 'listappend', fields: { list: m[1], item: m[2] } };

  // VAR = LIST.pop()
  m = t.match(/^(\w+)\s*=\s*(\w+)\.pop\s*\(\s*\)\s*$/);
  if (m) return { defId: 'listpop', fields: { var: m[1], list: m[2] } };

  // del VAR
  m = t.match(/^del\s+(\w+)\s*$/);
  if (m) return { defId: 'delete', fields: { name: m[1] } };

  // pass / break / continue
  if (/^pass\s*$/.test(t)) return { defId: 'pass', fields: {} };
  if (/^break\s*$/.test(t)) return { defId: 'break', fields: {} };
  if (/^continue\s*$/.test(t)) return { defId: 'continue', fields: {} };

  // RESULT = NAME(ARGS)  ‚Äî function call
  m = t.match(/^(\w+)\s*=\s*(\w+)\s*\(([^)]*)\)\s*$/);
  if (m) return { defId: 'call', fields: { result: m[1], name: m[2], args: m[3] } };

  // VAR = lambda ARGS: EXPR
  m = t.match(/^(\w+)\s*=\s*lambda\s+([^:]+):\s*(.+)$/);
  if (m) return { defId: 'lambda', fields: { var: m[1], args: m[2].trim(), expr: m[3].trim() } };

  // RESULT = MATH_EXPR  ‚Äî math or generic expression
  m = t.match(/^(\w+)\s*=\s*(.+)$/);
  if (m) {
    const rhs = m[2].trim();
    // Try to detect aug-assign patterns represented as X = X OP val ‚Äî skip, handled below
    // Check for math functions
    if (rhs.includes('math.') || /[+\-*/%()]/.test(rhs)) {
      return { defId: 'mathexpr', fields: { result: m[1], expr: rhs } };
    }
    return { defId: 'assign', fields: { name: m[1], value: rhs } };
  }

  // X += / -= / etc.
  m = t.match(/^(\w+)\s*(\+=|-=|\*=|\/=|\/\/=|%=|\*\*=)\s*(.+)$/);
  if (m) return { defId: 'augassign', fields: { name: m[1], op: m[2], value: m[3].trim() } };

  // with open(FILE, 'w') as f: f.write(CONTENT) ‚Äî inline write
  m = t.match(/^with\s+open\s*\((.+?),\s*'w'\)\s+as\s+\w+:\s*$/);
  if (m) return { defId: 'filewrite', fields: { file: m[1].trim(), content: '""' } };

  // Fallback ‚Äî treat as comment so nothing is lost
  return { defId: 'comment', fields: { text: t } };
}

function parseCodeToCanvas() {
  const ta = document.getElementById('codeTextarea');
  if (!ta) return;
  const raw = ta.value;
  if (!raw.trim()) { setStatus('Nothing to parse'); return; }

  // Confirm if canvas has stuff
  if (blockNodes.length > 0) {
    if (!confirm('This will replace the current canvas. Continue?')) return;
  }

  // Clear
  blockNodes.forEach(n => n.el.remove());
  blockNodes = []; connections = []; selectedBlock = null;
  document.getElementById('svgLayer').innerHTML = '';

  const lines = raw.split('\n');
  // Parse into a flat list of { defId, fields, indent, lineIdx }
  const parsed = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.trim() === '' || line.trim() === 'pass') continue; // skip blanks and lone pass
    const indent = getIndent(line);
    const match = matchLineToBlock(line);
    if (match) parsed.push({ ...match, indent, lineIdx: i });
  }

  if (parsed.length === 0) { setStatus('Nothing parsed'); return; }

  // Layout: columns by indent level, rows increment per item
  const COL_W = 240, ROW_H = 130, MARGIN_X = 60, MARGIN_Y = 40;
  const rowCounters = {}; // indent -> row count

  // Place nodes
  const nodeIdByParsedIdx = {};
  parsed.forEach((p, pi) => {
    const col = p.indent;
    rowCounters[col] = (rowCounters[col] || 0);
    const x = MARGIN_X + col * COL_W;
    const y = MARGIN_Y + rowCounters[col] * ROW_H;
    rowCounters[col]++;

    addBlock(p.defId, x, y);
    const node = blockNodes[blockNodes.length - 1];
    // Apply parsed fields
    Object.assign(node.fields, p.fields);
    // Update DOM inputs
    const inputs = node.el.querySelectorAll('input, select');
    node.def.fields.forEach((fd, fi) => {
      if (inputs[fi] && p.fields[fd.name] !== undefined) {
        inputs[fi].value = p.fields[fd.name];
      }
    });
    nodeIdByParsedIdx[pi] = node.id;
  });

  // Build connections: sequential bottom‚Üítop for same indent,
  // body connections for indent increases after a hasBody block
  for (let i = 1; i < parsed.length; i++) {
    const prev = parsed[i - 1];
    const curr = parsed[i];
    const prevId = nodeIdByParsedIdx[i - 1];
    const currId = nodeIdByParsedIdx[i];
    const prevNode = blockNodes.find(b => b.id === prevId);

    if (curr.indent > prev.indent) {
      // curr is a body child of most recent hasBody block at prev indent level
      // find the nearest ancestor with hasBody at indent = curr.indent - 1
      for (let j = i - 1; j >= 0; j--) {
        if (parsed[j].indent === curr.indent - 1) {
          const parentNode = blockNodes.find(b => b.id === nodeIdByParsedIdx[j]);
          if (parentNode && parentNode.def.hasBody) {
            connections.push({ from: nodeIdByParsedIdx[j], fromPort: 'body', to: currId, toPort: 'top' });
          }
          break;
        }
      }
    } else if (curr.indent === prev.indent) {
      // Same level ‚Äî wire bottom to top (sequential flow)
      connections.push({ from: prevId, fromPort: 'bottom', to: currId, toPort: 'top' });
    } else {
      // Dedent ‚Äî find the last node at curr.indent and connect to it
      for (let j = i - 1; j >= 0; j--) {
        if (parsed[j].indent === curr.indent) {
          connections.push({ from: nodeIdByParsedIdx[j], fromPort: 'bottom', to: currId, toPort: 'top' });
          break;
        }
      }
    }
  }

  ta._userEditing = false;
  updateHint();
  drawConnections();
  updateCodePreview();
  updateStatus();
  updateVars();

  // Flash canvas to indicate rebuild
  canvasWrap.classList.add('parse-flash');
  setTimeout(() => canvasWrap.classList.remove('parse-flash'), 450);

  setStatus(`Parsed ${parsed.length} blocks from code`);
}

// ============================================================
// PROXIMITY AUTO-CONNECT (while dragging a block)
// ============================================================
const PROX_RADIUS = 60; // canvas-units
let proximityTarget = null; // { nodeId, fromPort, toPort } ‚Äî pending auto-connect

function updateProximity(draggingId) {
  const dragNode = blockNodes.find(b => b.id === draggingId);
  if (!dragNode) { proximityTarget = null; return; }

  // Check all port combos of dragging block against all other blocks
  const dragPorts = ['top', 'bottom', ...(dragNode.def.hasBody ? ['body'] : [])];
  let best = null, bestDist = PROX_RADIUS;

  blockNodes.forEach(other => {
    if (other.id === draggingId) return;
    const otherPorts = ['top', 'bottom', ...(other.def.hasBody ? ['body'] : [])];
    dragPorts.forEach(dp => {
      const p1 = getPortCenter(draggingId, dp);
      if (!p1) return;
      otherPorts.forEach(op => {
        if (!isCompatiblePort(draggingId, dp, other.id, op)) return;
        const p2 = getPortCenter(other.id, op);
        if (!p2) return;
        const d = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        if (d < bestDist) {
          bestDist = d;
          best = { nodeId: other.id, fromPort: dp, toPort: op };
        }
      });
    });
  });

  // Update highlight
  if (proximityTarget) {
    const prev = blockNodes.find(b => b.id === proximityTarget.nodeId);
    if (prev) prev.el.classList.remove('proximity-snap');
  }
  proximityTarget = best;
  if (best) {
    const tn = blockNodes.find(b => b.id === best.nodeId);
    if (tn) tn.el.classList.add('proximity-snap');
  }
}

function commitProximityConnect(draggingId) {
  if (!proximityTarget) return;
  const tn = blockNodes.find(b => b.id === proximityTarget.nodeId);
  if (tn) tn.el.classList.remove('proximity-snap');
  makeConnection(draggingId, proximityTarget.fromPort, proximityTarget.nodeId, proximityTarget.toPort);
  proximityTarget = null;
  drawConnections();
  updateCodePreview();
}

// ============================================================
// Q MENU
// ============================================================
let qMenuOpen = false;
let qActiveCat = null;
let qDraggingDefId = null; // block being dragged out of Q menu

function buildQMenu() {
  const cats = document.getElementById('qMenuCats');
  const subcats = document.getElementById('qMenuSubcats');
  cats.innerHTML = ''; subcats.innerHTML = '';

  const catList = Object.keys(CAT_META);
  catList.forEach((cat, i) => {
    const tab = document.createElement('div');
    tab.className = 'q-cat-tab' + (i === 0 ? ' active' : '');
    tab.textContent = CAT_META[cat].label;
    tab.style.color = i === 0 ? CAT_META[cat].color : '';
    tab.dataset.cat = cat;
    tab.addEventListener('mousedown', e => { e.stopPropagation(); selectQCat(cat); });
    cats.appendChild(tab);

    const sub = document.createElement('div');
    sub.className = 'q-subcat' + (i === 0 ? ' active' : '');
    sub.textContent = CAT_META[cat].label;
    sub.style.borderLeftColor = i === 0 ? CAT_META[cat].color : 'transparent';
    sub.dataset.cat = cat;
    sub.addEventListener('mousedown', e => { e.stopPropagation(); selectQCat(cat); });
    subcats.appendChild(sub);
  });

  selectQCat(catList[0]);
}

function selectQCat(cat) {
  qActiveCat = cat;
  // Update tab + subcat active states
  document.querySelectorAll('.q-cat-tab').forEach(t => {
    const active = t.dataset.cat === cat;
    t.classList.toggle('active', active);
    t.style.color = active ? CAT_META[cat].color : '';
  });
  document.querySelectorAll('.q-subcat').forEach(s => {
    const active = s.dataset.cat === cat;
    s.classList.toggle('active', active);
    s.style.borderLeftColor = active ? CAT_META[s.dataset.cat].color : 'transparent';
  });

  // Render grid
  const grid = document.getElementById('qMenuGrid');
  grid.innerHTML = '';
  BLOCK_DEFS.filter(b => b.cat === cat).forEach(def => {
    const card = document.createElement('div');
    card.className = 'q-block-card';
    card.style.borderTopColor = def.color;

    // Render actual block header + body preview
    const fakeFields = {};
    def.fields.forEach(f => fakeFields[f.name] = f.default);

    const hdr = document.createElement('div');
    hdr.className = 'block-header';
    hdr.style.background = def.color + 'cc';
    hdr.innerHTML = `<span class="bh-icon">${def.icon}</span><span class="bh-label">${def.label}</span>`;

    const bod = document.createElement('div');
    bod.className = 'block-body';
    bod.style.fontSize = '11px';
    if (def.fields.length) {
      def.fields.forEach(f => {
        const row = document.createElement('div');
        row.className = 'block-field';
        row.innerHTML = `<label>${f.label}</label><span style="flex:1;background:var(--surface3);border-radius:4px;padding:3px 6px;font-family:JetBrains Mono,monospace;font-size:10px;color:var(--text-dim);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${f.default}</span>`;
        bod.appendChild(row);
      });
    } else {
      bod.innerHTML = `<span style="font-size:10px;color:var(--text-dim);font-family:JetBrains Mono,monospace;">${def.code(fakeFields)}</span>`;
    }

    card.appendChild(hdr);
    card.appendChild(bod);

    card.addEventListener('mousedown', e => {
      e.preventDefault(); e.stopPropagation();
      qDraggingDefId = def.id;
      // Start a real block drag ‚Äî place block at cursor, then let normal drag take over
      const r = canvasWrap.getBoundingClientRect();
      const x = (e.clientX - r.left - panX) / zoom - 90;
      const y = (e.clientY - r.top  - panY) / zoom - 30;
      addBlock(def.id, x, y);
      const newNode = blockNodes[blockNodes.length - 1];
      draggingBlock = newNode.id;
      dragOffset.x = 90 / zoom;
      dragOffset.y = 30 / zoom;
      newNode.el.classList.add('dragging');
    });

    grid.appendChild(card);
  });
}

function openQMenu() {
  if (qMenuOpen) return;
  qMenuOpen = true;
  const m = document.getElementById('qMenu');
  m.style.display = 'flex';
  buildQMenu();
}

function closeQMenu() {
  if (!qMenuOpen) return;
  qMenuOpen = false;
  document.getElementById('qMenu').style.display = 'none';
}

// Q key hold
let qKeyDown = false;
document.addEventListener('keydown', e => {
  // Don't trigger if user is typing in an input
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  if (e.key === 'q' || e.key === 'Q') {
    if (!qKeyDown) { qKeyDown = true; openQMenu(); }
    e.preventDefault();
  }
  if (e.key === 'Escape') { closeQMenu(); cancelWireConnect(); }
});
document.addEventListener('keyup', e => {
  if (e.key === 'q' || e.key === 'Q') {
    qKeyDown = false;
    closeQMenu();
  }
});

// ============================================================
// INIT
// ============================================================
buildPalette();
updateCodePreview();
initCodeEditor();

// Touch device hint
if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
  const hint = document.getElementById('canvasHintText');
  if (hint) hint.innerHTML = 'Tap <strong style="color:var(--accent)">Blocks</strong> below<br>to add blocks to your program';
}

// Tap canvas to dismiss any open mobile drawer
document.getElementById('canvasWrap').addEventListener('touchstart', e => {
  const drawer = document.getElementById('mobileDrawer');
  const moreDrawer = document.getElementById('mobileMoreDrawer');
  const panel = document.getElementById('mobilePanelOverlay');
  if (drawer.classList.contains('open') || moreDrawer.classList.contains('open') || panel.classList.contains('open')) {
    closeAllMobile();
    document.querySelectorAll('.mobile-nav-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('navCanvas').classList.add('active');
  }
}, { passive: true });</script>
</body>
</html>
